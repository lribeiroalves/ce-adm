14:29:44.512 [MainThread] INFO    thonny: Thonny version: 4.1.7
14:29:44.513 [MainThread] INFO    thonny: cwd: D:\Lucas Ribeiro\Programas\ESP32\MicroPython\thonny-4.1.7-windows-portable
14:29:44.513 [MainThread] INFO    thonny: original argv: []
14:29:44.513 [MainThread] INFO    thonny: sys.executable: D:\Lucas Ribeiro\Programas\ESP32\MicroPython\thonny-4.1.7-windows-portable\pythonw.exe
14:29:44.513 [MainThread] INFO    thonny: sys.argv: ['D:\\Lucas Ribeiro\\Programas\\ESP32\\MicroPython\\thonny-4.1.7-windows-portable\\thonny.exe']
14:29:44.513 [MainThread] INFO    thonny: sys.path: ['D:\\Lucas Ribeiro\\Programas\\ESP32\\MicroPython\\thonny-4.1.7-windows-portable\\python310.zip', 'D:\\Lucas Ribeiro\\Programas\\ESP32\\MicroPython\\thonny-4.1.7-windows-portable\\DLLs', 'D:\\Lucas Ribeiro\\Programas\\ESP32\\MicroPython\\thonny-4.1.7-windows-portable\\lib', 'D:\\Lucas Ribeiro\\Programas\\ESP32\\MicroPython\\thonny-4.1.7-windows-portable', 'D:\\Lucas Ribeiro\\Programas\\ESP32\\MicroPython\\thonny-4.1.7-windows-portable\\lib\\site-packages']
14:29:44.513 [MainThread] INFO    thonny: sys.flags: sys.flags(debug=0, inspect=0, interactive=0, optimize=0, dont_write_bytecode=0, no_user_site=1, no_site=0, ignore_environment=1, verbose=0, bytes_warning=0, quiet=0, hash_randomization=1, isolated=1, dev_mode=False, utf8_mode=0, warn_default_encoding=0, int_max_str_digits=-1)
14:29:44.574 [MainThread] INFO    thonny.workbench: Starting Workbench
14:29:44.799 [MainThread] INFO    thonny.workbench: Creating runner
14:29:44.801 [MainThread] INFO    thonny.workbench: Start loading plugins
14:29:44.884 [MainThread] INFO    thonny.workbench: Done loading plugins
14:29:44.971 [MainThread] INFO    thonny.workbench: Opening views
14:29:45.467 [MainThread] INFO    thonny.running: Starting the backend: ['D:\\Lucas Ribeiro\\Programas\\ESP32\\MicroPython\\thonny-4.1.7-windows-portable\\python.exe', '-s', '-u', '-B', 'D:\\Lucas Ribeiro\\Programas\\ESP32\\MicroPython\\thonny-4.1.7-windows-portable\\lib\\site-packages\\thonny\\plugins\\esp\\esp_back.py', "{'clean': False, 'port': 'COM9', 'dtr': None, 'rts': None, 'submit_mode': None, 'interrupt_on_connect': True, 'write_block_size': None, 'write_block_delay': None, 'proxy_class': 'ESP32Proxy', 'sync_time': True, 'validate_time': False, 'local_rtc': True}"] C:\Users\lucas
14:29:45.620 [MainThread] INFO    thonny.plugins.micropython.mp_front: Listing serial ports
14:29:45.630 [Thread-2 (_listen_stdout)] INFO    thonny.running: Reader got EOF
14:29:45.753 [MainThread] INFO    thonny.shell: BaseShellText._on_backend_terminated
14:29:55.092 [MainThread] INFO    thonny.plugins.micropython.mp_front: Listing serial ports
14:29:56.144 [MainThread] INFO    thonny.running: Starting the backend: ['D:\\Lucas Ribeiro\\Programas\\ESP32\\MicroPython\\thonny-4.1.7-windows-portable\\python.exe', '-s', '-u', '-B', 'D:\\Lucas Ribeiro\\Programas\\ESP32\\MicroPython\\thonny-4.1.7-windows-portable\\lib\\site-packages\\thonny\\plugins\\esp\\esp_back.py', "{'clean': False, 'port': 'COM9', 'dtr': None, 'rts': None, 'submit_mode': None, 'interrupt_on_connect': True, 'write_block_size': None, 'write_block_delay': None, 'proxy_class': 'ESP32Proxy', 'sync_time': True, 'validate_time': False, 'local_rtc': True}"] C:\Users\lucas
14:29:56.290 [MainThread] INFO    thonny.shell: BaseShellText.restart(False)
14:29:56.309 [MainThread] INFO    thonny.plugins.micropython.mp_front: Listing serial ports
14:29:59.971 [MainThread] INFO    thonny.ui_utils: Parent y: -8, rooty: 43, vrooty: 0
14:29:59.972 [MainThread] INFO    thonny.ui_utils: Placing .!nodechoicedialog with geometry +1156+401
14:30:07.354 [MainThread] INFO    thonny.ui_utils: Restoring focus to .
14:30:10.994 [MainThread] INFO    thonny: TIME/MODS 26.489 Before Run (+319 modules)
14:30:10.994 [MainThread] INFO    thonny: NEW MODS ['__future__', '_bisect', '_blake2', '_bz2', '_compat_pickle', '_compression', '_ctypes', '_datetime', '_hashlib', '_heapq', '_json', '_lzma', '_pickle', '_queue', '_random', '_sha512', '_socket', '_ssl', '_struct', '_tkinter', '_uuid', 'adafruit_board_toolkit', 'adafruit_board_toolkit._list_ports_windows', 'base64', 'binascii', 'bisect', 'bz2', 'calendar', 'configparser', 'ctypes', 'ctypes._endian', 'ctypes.wintypes', 'datetime', 'difflib', 'email', 'email._encoded_words', 'email._parseaddr', 'email._policybase', 'email.base64mime', 'email.charset', 'email.encoders', 'email.errors', 'email.feedparser', 'email.header', 'email.iterators', 'email.message', 'email.parser', 'email.quoprimime', 'email.utils', 'encodings.ascii', 'errno', 'faulthandler', 'filecmp', 'fnmatch', 'gc', 'gettext', 'glob', 'hashlib', 'heapq', 'http', 'http.client', 'jedi', 'jedi._compatibility', 'jedi.api', 'jedi.api.classes', 'jedi.api.completion', 'jedi.api.completion_cache', 'jedi.api.environment', 'jedi.api.errors', 'jedi.api.exceptions', 'jedi.api.file_name', 'jedi.api.helpers', 'jedi.api.interpreter', 'jedi.api.keywords', 'jedi.api.project', 'jedi.api.refactoring', 'jedi.api.refactoring.extract', 'jedi.api.strings', 'jedi.cache', 'jedi.common', 'jedi.debug', 'jedi.file_io', 'jedi.inference', 'jedi.inference.analysis', 'jedi.inference.arguments', 'jedi.inference.base_value', 'jedi.inference.cache', 'jedi.inference.compiled', 'jedi.inference.compiled.access', 'jedi.inference.compiled.getattr_static', 'jedi.inference.compiled.mixed', 'jedi.inference.compiled.subprocess', 'jedi.inference.compiled.subprocess.functions', 'jedi.inference.compiled.value', 'jedi.inference.context', 'jedi.inference.docstring_utils', 'jedi.inference.docstrings', 'jedi.inference.filters', 'jedi.inference.flow_analysis', 'jedi.inference.gradual', 'jedi.inference.gradual.annotation', 'jedi.inference.gradual.base', 'jedi.inference.gradual.conversion', 'jedi.inference.gradual.generics', 'jedi.inference.gradual.stub_value', 'jedi.inference.gradual.type_var', 'jedi.inference.gradual.typeshed', 'jedi.inference.gradual.typing', 'jedi.inference.gradual.utils', 'jedi.inference.helpers', 'jedi.inference.imports', 'jedi.inference.lazy_value', 'jedi.inference.names', 'jedi.inference.param', 'jedi.inference.parser_cache', 'jedi.inference.recursion', 'jedi.inference.references', 'jedi.inference.signature', 'jedi.inference.syntax_tree', 'jedi.inference.sys_path', 'jedi.inference.utils', 'jedi.inference.value', 'jedi.inference.value.decorator', 'jedi.inference.value.dynamic_arrays', 'jedi.inference.value.function', 'jedi.inference.value.instance', 'jedi.inference.value.iterable', 'jedi.inference.value.klass', 'jedi.inference.value.module', 'jedi.inference.value.namespace', 'jedi.parser_utils', 'jedi.plugins', 'jedi.plugins.django', 'jedi.plugins.flask', 'jedi.plugins.pytest', 'jedi.plugins.registry', 'jedi.plugins.stdlib', 'jedi.settings', 'json', 'json.decoder', 'json.encoder', 'json.scanner', 'locale', 'lzma', 'math', 'msvcrt', 'nturl2path', 'parso', 'parso._compatibility', 'parso.cache', 'parso.file_io', 'parso.grammar', 'parso.normalizer', 'parso.parser', 'parso.pgen2', 'parso.pgen2.generator', 'parso.pgen2.grammar_parser', 'parso.python', 'parso.python.diff', 'parso.python.errors', 'parso.python.parser', 'parso.python.pep8', 'parso.python.prefix', 'parso.python.token', 'parso.python.tokenize', 'parso.python.tree', 'parso.tree', 'parso.utils', 'pathlib', 'pickle', 'pkgutil', 'platform', 'posixpath', 'pydoc', 'pydoc_data', 'pydoc_data.topics', 'queue', 'quopri', 'random', 'select', 'selectors', 'serial', 'serial.serialutil', 'serial.serialwin32', 'serial.tools', 'serial.tools.list_ports_common', 'serial.win32', 'shlex', 'shutil', 'signal', 'socket', 'ssl', 'struct', 'subprocess', 'sysconfig', 'tempfile', 'textwrap', 'thonny.assistance', 'thonny.ast_utils', 'thonny.backend', 'thonny.base_file_browser', 'thonny.codeview', 'thonny.config', 'thonny.config_ui', 'thonny.editor_helpers', 'thonny.editors', 'thonny.languages', 'thonny.memory', 'thonny.misc_utils', 'thonny.plugins', 'thonny.plugins.about', 'thonny.plugins.assistant_config_page', 'thonny.plugins.ast_view', 'thonny.plugins.autocomplete', 'thonny.plugins.backend', 'thonny.plugins.backend_config_page', 'thonny.plugins.base_syntax_themes', 'thonny.plugins.base_ui_themes', 'thonny.plugins.birdseye_frontend', 'thonny.plugins.calltip', 'thonny.plugins.cells', 'thonny.plugins.circuitpython', 'thonny.plugins.circuitpython.cirpy_front', 'thonny.plugins.clean_ui_themes', 'thonny.plugins.coloring', 'thonny.plugins.commenting_indenting', 'thonny.plugins.common_editing_commands', 'thonny.plugins.cpython_backend', 'thonny.plugins.cpython_backend.cp_back', 'thonny.plugins.cpython_frontend', 'thonny.plugins.cpython_frontend.cp_front', 'thonny.plugins.cpython_ssh', 'thonny.plugins.cpython_ssh.cps_front', 'thonny.plugins.debugger', 'thonny.plugins.dock_user_windows_frontend', 'thonny.plugins.editor_config_page', 'thonny.plugins.esp', 'thonny.plugins.esp.esp_back', 'thonny.plugins.ev3', 'thonny.plugins.event_logging', 'thonny.plugins.event_view', 'thonny.plugins.files', 'thonny.plugins.find_replace', 'thonny.plugins.general_config_page', 'thonny.plugins.goto_definition', 'thonny.plugins.heap', 'thonny.plugins.help', 'thonny.plugins.highlight_names', 'thonny.plugins.locals_marker', 'thonny.plugins.microbit', 'thonny.plugins.micropython', 'thonny.plugins.micropython.bare_metal_backend', 'thonny.plugins.micropython.base_flashing_dialog', 'thonny.plugins.micropython.connection', 'thonny.plugins.micropython.esptool_dialog', 'thonny.plugins.micropython.mp_back', 'thonny.plugins.micropython.mp_common', 'thonny.plugins.micropython.mp_front', 'thonny.plugins.micropython.uf2dialog', 'thonny.plugins.micropython.webrepl_connection', 'thonny.plugins.misc_analyzers', 'thonny.plugins.mypy', 'thonny.plugins.notes', 'thonny.plugins.object_inspector', 'thonny.plugins.outline', 'thonny.plugins.paren_matcher', 'thonny.plugins.pgzero_frontend', 'thonny.plugins.pi', 'thonny.plugins.pip_gui', 'thonny.plugins.prime_inventor', 'thonny.plugins.printing', 'thonny.plugins.pylint', 'thonny.plugins.pylint.messages', 'thonny.plugins.pythontutor', 'thonny.plugins.remove_old_data_dir', 'thonny.plugins.replayer', 'thonny.plugins.rp2040', 'thonny.plugins.rpi_pico', 'thonny.plugins.run_debug_config_page', 'thonny.plugins.shell_config_page', 'thonny.plugins.shell_macro', 'thonny.plugins.statement_boxes', 'thonny.plugins.stdlib_error_helpers', 'thonny.plugins.system_shell', 'thonny.plugins.terminal_config_page', 'thonny.plugins.theme_and_font_config_page', 'thonny.plugins.thonny_folders', 'thonny.plugins.todo_view', 'thonny.plugins.tomorrow_syntax_theme', 'thonny.plugins.variables', 'thonny.roughparse', 'thonny.rst_utils', 'thonny.running', 'thonny.shell', 'thonny.terminal', 'thonny.tktextext', 'thonny.token_utils', 'thonny.ui_utils', 'thonny.workbench', 'thonny.workdlg', 'tkinter', 'tkinter.commondialog', 'tkinter.constants', 'tkinter.dialog', 'tkinter.filedialog', 'tkinter.font', 'tkinter.messagebox', 'tkinter.simpledialog', 'tkinter.ttk', 'urllib', 'urllib.error', 'urllib.parse', 'urllib.request', 'urllib.response', 'uu', 'uuid', 'webbrowser', 'zipfile', 'zlib']
14:30:10.995 [MainThread] INFO    thonny.running: Trying to execute current but runner is 'running'
14:30:12.006 [MainThread] INFO    thonny: TIME/MODS 1.011 After Run 
14:30:19.775 [MainThread] INFO    thonny.running: Killing backend process
14:30:19.799 [Thread-4 (_listen_stdout)] INFO    thonny.running: Reader got EOF
14:30:19.878 [MainThread] INFO    thonny.shell: BaseShellText._on_backend_terminated
14:30:19.887 [MainThread] INFO    thonny.running: Starting the backend: ['D:\\Lucas Ribeiro\\Programas\\ESP32\\MicroPython\\thonny-4.1.7-windows-portable\\python.exe', '-s', '-u', '-B', 'D:\\Lucas Ribeiro\\Programas\\ESP32\\MicroPython\\thonny-4.1.7-windows-portable\\lib\\site-packages\\thonny\\plugins\\esp\\esp_back.py', "{'clean': True, 'port': 'COM9', 'dtr': None, 'rts': None, 'submit_mode': None, 'interrupt_on_connect': True, 'write_block_size': None, 'write_block_delay': None, 'proxy_class': 'ESP32Proxy', 'sync_time': True, 'validate_time': False, 'local_rtc': True}"] C:\Users\lucas
14:30:20.039 [MainThread] INFO    thonny.shell: BaseShellText.restart(False)
14:30:20.061 [MainThread] INFO    thonny.plugins.micropython.mp_front: Listing serial ports
14:30:26.376 [MainThread] INFO    thonny: TIME/MODS 14.371 Before Run 
14:30:26.376 [MainThread] INFO    thonny.running: Trying to execute current but runner is 'running'
14:30:27.393 [MainThread] INFO    thonny: TIME/MODS 1.016 After Run 
14:30:34.932 [MainThread] INFO    thonny.plugins.micropython.mp_front: Listing serial ports
14:30:35.092 [MainThread] INFO    thonny.ui_utils: Parent y: -8, rooty: 43, vrooty: 0
14:30:35.092 [MainThread] INFO    thonny.ui_utils: Placing .!configurationdialog with geometry +953+231
14:30:37.643 [Thread-8 (_download_variants)] INFO    thonny.plugins.micropython.base_flashing_dialog: Downloading 'https://raw.githubusercontent.com/thonny/thonny/master/data/micropython-variants-esptool.json'
14:30:37.695 [MainThread] INFO    thonny.ui_utils: Parent y: 231, rooty: 262, vrooty: 0
14:30:37.695 [MainThread] INFO    thonny.ui_utils: Placing .!configurationdialog.!espflashingdialog with geometry +1008+294
14:30:37.883 [Thread-8 (_download_variants)] INFO    thonny.plugins.micropython.base_flashing_dialog: Got 30 variants
14:30:37.883 [Thread-8 (_download_variants)] INFO    thonny.plugins.micropython.base_flashing_dialog: Downloading 'https://micropython.org/download/ARDUINO_NANO_ESP32'
14:30:39.957 [Thread-8 (_download_variants)] INFO    thonny.plugins.micropython.base_flashing_dialog: Using '20241223-v1.25.0-preview.160.gc73204128' as prerelease substitute
14:30:50.386 [MainThread] INFO    thonny.ui_utils: Restoring focus to .!configurationdialog.!espflashingdialog
14:30:50.392 [MainThread] INFO    thonny.plugins.micropython.esptool_dialog: Detected family 'esp32'
14:30:52.252 [MainThread] INFO    thonny.plugins.micropython.esptool_dialog: Disconnecting
14:30:52.252 [MainThread] INFO    thonny.running: Killing backend process
14:30:52.281 [Thread-6 (_listen_stdout)] INFO    thonny.running: Reader got EOF
14:30:52.469 [MainThread] INFO    thonny.shell: BaseShellText._on_backend_terminated
14:33:28.135 [MainThread] INFO    thonny.running: Starting the backend: ['D:\\Lucas Ribeiro\\Programas\\ESP32\\MicroPython\\thonny-4.1.7-windows-portable\\python.exe', '-s', '-u', '-B', 'D:\\Lucas Ribeiro\\Programas\\ESP32\\MicroPython\\thonny-4.1.7-windows-portable\\lib\\site-packages\\thonny\\plugins\\esp\\esp_back.py', "{'clean': False, 'port': 'COM9', 'dtr': None, 'rts': None, 'submit_mode': None, 'interrupt_on_connect': True, 'write_block_size': None, 'write_block_delay': None, 'proxy_class': 'ESP32Proxy', 'sync_time': True, 'validate_time': False, 'local_rtc': True}"] C:\Users\lucas
14:33:28.314 [MainThread] INFO    thonny.shell: BaseShellText.restart(False)
14:33:28.358 [MainThread] INFO    thonny.plugins.micropython.mp_front: Listing serial ports
14:33:29.631 [MainThread] INFO    thonny.plugins.micropython.mp_front: Listing serial ports
14:33:32.004 [MainThread] INFO    thonny.ui_utils: Parent y: -8, rooty: 43, vrooty: 0
14:33:32.004 [MainThread] INFO    thonny.ui_utils: Placing .!nodechoicedialog2 with geometry +1156+401
14:33:33.071 [MainThread] INFO    thonny.ui_utils: Parent y: -8, rooty: 43, vrooty: 0
14:33:33.071 [MainThread] INFO    thonny.ui_utils: Placing .!backendfiledialog with geometry +1008+181
17:19:51.585 [MainThread] INFO    thonny.ui_utils: Parent y: -8, rooty: 43, vrooty: 0
17:19:51.585 [MainThread] INFO    thonny.ui_utils: Placing .!nodechoicedialog3 with geometry +1156+401
17:20:08.501 [MainThread] INFO    thonny.ui_utils: Restoring focus to .
17:20:08.501 [MainThread] INFO    thonny.editors: Save dialog returned 'D:/Lucas Ribeiro/Programas/ESP32/MicroPython/exemplos/adc_pwm' with typevariable 'Python files'
17:25:51.824 [Thread-10 (_listen_stdout)] INFO    thonny.running: Reader got EOF
17:25:51.960 [MainThread] INFO    thonny.shell: BaseShellText._on_backend_terminated
17:31:40.695 [MainThread] INFO    thonny.plugins.micropython.mp_front: Listing serial ports
17:31:43.007 [MainThread] INFO    thonny.running: Starting the backend: ['D:\\Lucas Ribeiro\\Programas\\ESP32\\MicroPython\\thonny-4.1.7-windows-portable\\python.exe', '-s', '-u', '-B', 'D:\\Lucas Ribeiro\\Programas\\ESP32\\MicroPython\\thonny-4.1.7-windows-portable\\lib\\site-packages\\thonny\\plugins\\esp\\esp_back.py', "{'clean': False, 'port': 'COM5', 'dtr': None, 'rts': None, 'submit_mode': None, 'interrupt_on_connect': True, 'write_block_size': None, 'write_block_delay': None, 'proxy_class': 'ESP32Proxy', 'sync_time': True, 'validate_time': False, 'local_rtc': True}"] C:\Users\lucas
17:31:43.713 [MainThread] INFO    thonny.shell: BaseShellText.restart(False)
17:31:43.730 [MainThread] INFO    thonny.plugins.micropython.mp_front: Listing serial ports
17:31:49.000 [MainThread] INFO    thonny.plugins.micropython.mp_front: Listing serial ports
17:32:32.919 [MainThread] INFO    thonny: TIME/MODS 10925.526 Before Run (+36 modules)
17:32:32.919 [MainThread] INFO    thonny: NEW MODS ['argparse', 'array', 'encodings.idna', 'esptool', 'esptool.bin_image', 'esptool.cmds', 'esptool.config', 'esptool.loader', 'esptool.reset', 'esptool.targets', 'esptool.targets.esp32', 'esptool.targets.esp32c2', 'esptool.targets.esp32c3', 'esptool.targets.esp32c5', 'esptool.targets.esp32c5beta3', 'esptool.targets.esp32c6', 'esptool.targets.esp32c61', 'esptool.targets.esp32c6beta', 'esptool.targets.esp32h2', 'esptool.targets.esp32h2beta1', 'esptool.targets.esp32h2beta2', 'esptool.targets.esp32p4', 'esptool.targets.esp32s2', 'esptool.targets.esp32s3', 'esptool.targets.esp32s3beta2', 'esptool.targets.esp8266', 'esptool.uf2_writer', 'esptool.util', 'intelhex', 'intelhex.compat', 'intelhex.getsizeof', 'serial.tools.list_ports', 'serial.tools.list_ports_windows', 'stringprep', 'thonny.plugins.micropython.pip_gui', 'unicodedata']
17:32:32.976 [MainThread] INFO    thonny.running: Prepared clean state for executing ToplevelCommand(args=['-c'], args_str='-c $EDITOR_CONTENT', cmd_line='%Run -c $EDITOR_CONTENT', tty_mode=True, source='from machine import ADC, PWM, Pin\nimport time\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# ADC\n\n# Configurar o pino ao qual o sensor está conectado (por exemplo, GPIO 32)\nadc_pin = Pin(34)\n\n# Inicializar o ADC\nadc = ADC(adc_pin)\n\n# Configurar a atenuação (opcional, melhora a leitura em diferentes ranges de tensão)\nadc.atten(ADC.ATTN_11DB)  # Opções: ADC.ATTN_0DB, ADC.ATTN_2_5DB, ADC.ATTN_6DB, ADC.ATTN_11DB\n# A atenuação de 11DB é a máxima e permite leituras de 0V a 3,6V\n\n# Configurar a largura do bit (opcional)\nadc.width(ADC.WIDTH_12BIT)  # Opções: ADC.WIDTH_9BIT, ADC.WIDTH_10BIT, ADC.WIDTH_11BIT, ADC.WIDTH_12BIT\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# PWM\n\n# Configurar o pino GPIO onde o PWM será gerado (por exemplo, GPIO15)\npwm_pin = Pin(23)\n\n# Inicializar a saída PWM\npwm = PWM(pwm_pin)\n\n# Configurar a frequência do PWM\npwm.freq(1000)  # 1000 Hz (1 kHz)\n\n# Configurar o duty cycle do PWM (0-1023)\npwm.duty(512)  # 50% do duty cycle\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# Alterar o duty cycle ao longo do tempo e ler o valor do ADC\n\nwhile True:\n    for duty in range(0, 1024, 64):\n        pwm.duty(duty)\n        \n        valor_adc = adc.read()\n        print("Valor ADC:", valor_adc)\n        \n        time.sleep(0.1)\n\n"""\nO ESP32 possui múltiplos pinos que podem ser usados como entradas ADC (Conversor Analógico-Digital). Existem duas unidades de ADC, ADC1 e ADC2, com um total de 18 canais ADC disponíveis. Aqui estão os pinos que você pode usar para ADC:\n\nADC1 (8 canais)\nGPIO32 (ADC1_CH4)\n\nGPIO33 (ADC1_CH5)\n\nGPIO34 (ADC1_CH6)\n\nGPIO35 (ADC1_CH7)\n\nGPIO36 (ADC1_CH0)\n\nGPIO37 (ADC1_CH1)\n\nGPIO38 (ADC1_CH2)\n\nGPIO39 (ADC1_CH3)\n\nADC2 (10 canais)\nGPIO0 (ADC2_CH1)\n\nGPIO2 (ADC2_CH2)\n\nGPIO4 (ADC2_CH0)\n\nGPIO12 (ADC2_CH5)\n\nGPIO13 (ADC2_CH4)\n\nGPIO14 (ADC2_CH6)\n\nGPIO15 (ADC2_CH3)\n\nGPIO25 (ADC2_CH8)\n\nGPIO26 (ADC2_CH9)\n\nGPIO27 (ADC2_CH7)\n\nNota:\nADC1 vs ADC2:\n\nADC1: Pode ser usado para leituras ADC normalmente, mesmo durante o uso do WiFi.\n\nADC2: Pode ter conflitos quando o WiFi está ativo, pois compartilha recursos de hardware com o WiFi do ESP32.\n"""', name='Run', argv=[], id='cmd_71', local_cwd='C:\\Users\\lucas')
17:32:32.976 [MainThread] INFO    thonny.plugins.micropython.mp_front: Listing serial ports
17:32:32.981 [MainThread] INFO    thonny: TIME/MODS 0.062 After Run 
17:34:42.196 [MainThread] INFO    thonny: TIME/MODS 129.216 Before Run 
17:34:42.258 [MainThread] INFO    thonny.running: Prepared clean state for executing ToplevelCommand(args=['-c'], args_str='-c $EDITOR_CONTENT', cmd_line='%Run -c $EDITOR_CONTENT', tty_mode=True, source='from machine import ADC, PWM, Pin\nimport time\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# ADC\n\n# Configurar o pino ao qual o sensor está conectado (por exemplo, GPIO 32)\nadc_pin = Pin(32)\n\n# Inicializar o ADC\nadc = ADC(adc_pin)\n\n# Configurar a atenuação (opcional, melhora a leitura em diferentes ranges de tensão)\nadc.atten(ADC.ATTN_11DB)  # Opções: ADC.ATTN_0DB, ADC.ATTN_2_5DB, ADC.ATTN_6DB, ADC.ATTN_11DB\n# A atenuação de 11DB é a máxima e permite leituras de 0V a 3,6V\n\n# Configurar a largura do bit (opcional)\nadc.width(ADC.WIDTH_12BIT)  # Opções: ADC.WIDTH_9BIT, ADC.WIDTH_10BIT, ADC.WIDTH_11BIT, ADC.WIDTH_12BIT\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# PWM\n\n# Configurar o pino GPIO onde o PWM será gerado (por exemplo, GPIO15)\npwm_pin = Pin(15)\n\n# Inicializar a saída PWM\npwm = PWM(pwm_pin)\n\n# Configurar a frequência do PWM\npwm.freq(1000)  # 1000 Hz (1 kHz)\n\n# Configurar o duty cycle do PWM (0-1023)\npwm.duty(512)  # 50% do duty cycle\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# Alterar o duty cycle ao longo do tempo e ler o valor do ADC\n\nwhile True:\n    for duty in range(0, 1024, 64):\n        pwm.duty(duty)\n        \n        valor_adc = adc.read()\n        print("Valor ADC:", valor_adc)\n        \n        time.sleep(0.1)\n\n"""\nO ESP32 possui múltiplos pinos que podem ser usados como entradas ADC (Conversor Analógico-Digital). Existem duas unidades de ADC, ADC1 e ADC2, com um total de 18 canais ADC disponíveis. Aqui estão os pinos que você pode usar para ADC:\n\nADC1 (8 canais)\nGPIO32 (ADC1_CH4)\n\nGPIO33 (ADC1_CH5)\n\nGPIO34 (ADC1_CH6)\n\nGPIO35 (ADC1_CH7)\n\nGPIO36 (ADC1_CH0)\n\nGPIO37 (ADC1_CH1)\n\nGPIO38 (ADC1_CH2)\n\nGPIO39 (ADC1_CH3)\n\nADC2 (10 canais)\nGPIO0 (ADC2_CH1)\n\nGPIO2 (ADC2_CH2)\n\nGPIO4 (ADC2_CH0)\n\nGPIO12 (ADC2_CH5)\n\nGPIO13 (ADC2_CH4)\n\nGPIO14 (ADC2_CH6)\n\nGPIO15 (ADC2_CH3)\n\nGPIO25 (ADC2_CH8)\n\nGPIO26 (ADC2_CH9)\n\nGPIO27 (ADC2_CH7)\n\nNota:\nADC1 vs ADC2:\n\nADC1: Pode ser usado para leituras ADC normalmente, mesmo durante o uso do WiFi.\n\nADC2: Pode ter conflitos quando o WiFi está ativo, pois compartilha recursos de hardware com o WiFi do ESP32.\n"""', name='Run', argv=[], id='cmd_81', local_cwd='C:\\Users\\lucas')
17:34:42.258 [MainThread] INFO    thonny.plugins.micropython.mp_front: Listing serial ports
17:34:42.263 [MainThread] INFO    thonny: TIME/MODS 0.067 After Run 
17:34:58.791 [MainThread] INFO    thonny: TIME/MODS 16.528 Before Run 
17:34:58.859 [MainThread] INFO    thonny.running: Prepared clean state for executing ToplevelCommand(args=['-c'], args_str='-c $EDITOR_CONTENT', cmd_line='%Run -c $EDITOR_CONTENT', tty_mode=True, source='from machine import ADC, PWM, Pin\nimport time\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# ADC\n\n# Configurar o pino ao qual o sensor está conectado (por exemplo, GPIO 32)\nadc_pin = Pin(32)\n\n# Inicializar o ADC\nadc = ADC(adc_pin)\n\n# Configurar a atenuação (opcional, melhora a leitura em diferentes ranges de tensão)\nadc.atten(ADC.ATTN_11DB)  # Opções: ADC.ATTN_0DB, ADC.ATTN_2_5DB, ADC.ATTN_6DB, ADC.ATTN_11DB\n# A atenuação de 11DB é a máxima e permite leituras de 0V a 3,6V\n\n# Configurar a largura do bit (opcional)\nadc.width(ADC.WIDTH_12BIT)  # Opções: ADC.WIDTH_9BIT, ADC.WIDTH_10BIT, ADC.WIDTH_11BIT, ADC.WIDTH_12BIT\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# PWM\n\n# Configurar o pino GPIO onde o PWM será gerado (por exemplo, GPIO15)\npwm_pin = Pin(15)\n\n# Inicializar a saída PWM\npwm = PWM(pwm_pin)\n\n# Configurar a frequência do PWM\npwm.freq(1000)  # 1000 Hz (1 kHz)\n\n# Configurar o duty cycle do PWM (0-1023)\npwm.duty(512)  # 50% do duty cycle\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# Alterar o duty cycle ao longo do tempo e ler o valor do ADC\n\nwhile True:\n    for duty in range(0, 1024, 64):\n        print(duty)\n        pwm.duty(duty)\n        \n        valor_adc = adc.read()\n        print("Valor ADC:", valor_adc)\n        \n        time.sleep(0.1)\n\n"""\nO ESP32 possui múltiplos pinos que podem ser usados como entradas ADC (Conversor Analógico-Digital). Existem duas unidades de ADC, ADC1 e ADC2, com um total de 18 canais ADC disponíveis. Aqui estão os pinos que você pode usar para ADC:\n\nADC1 (8 canais)\nGPIO32 (ADC1_CH4)\n\nGPIO33 (ADC1_CH5)\n\nGPIO34 (ADC1_CH6)\n\nGPIO35 (ADC1_CH7)\n\nGPIO36 (ADC1_CH0)\n\nGPIO37 (ADC1_CH1)\n\nGPIO38 (ADC1_CH2)\n\nGPIO39 (ADC1_CH3)\n\nADC2 (10 canais)\nGPIO0 (ADC2_CH1)\n\nGPIO2 (ADC2_CH2)\n\nGPIO4 (ADC2_CH0)\n\nGPIO12 (ADC2_CH5)\n\nGPIO13 (ADC2_CH4)\n\nGPIO14 (ADC2_CH6)\n\nGPIO15 (ADC2_CH3)\n\nGPIO25 (ADC2_CH8)\n\nGPIO26 (ADC2_CH9)\n\nGPIO27 (ADC2_CH7)\n\nNota:\nADC1 vs ADC2:\n\nADC1: Pode ser usado para leituras ADC normalmente, mesmo durante o uso do WiFi.\n\nADC2: Pode ter conflitos quando o WiFi está ativo, pois compartilha recursos de hardware com o WiFi do ESP32.\n"""', name='Run', argv=[], id='cmd_114', local_cwd='C:\\Users\\lucas')
17:34:58.859 [MainThread] INFO    thonny.plugins.micropython.mp_front: Listing serial ports
17:34:58.865 [MainThread] INFO    thonny: TIME/MODS 0.074 After Run 
17:36:01.436 [MainThread] INFO    thonny: TIME/MODS 62.571 Before Run 
17:36:01.463 [MainThread] INFO    thonny.running: Prepared clean state for executing ToplevelCommand(args=['-c'], args_str='-c $EDITOR_CONTENT', cmd_line='%Run -c $EDITOR_CONTENT', tty_mode=True, source='from machine import ADC, PWM, Pin\nimport time\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# ADC\n\n# Configurar o pino ao qual o sensor está conectado (por exemplo, GPIO 32)\nadc_pin = Pin(32)\n\n# Inicializar o ADC\nadc = ADC(adc_pin)\n\n# Configurar a atenuação (opcional, melhora a leitura em diferentes ranges de tensão)\nadc.atten(ADC.ATTN_11DB)  # Opções: ADC.ATTN_0DB, ADC.ATTN_2_5DB, ADC.ATTN_6DB, ADC.ATTN_11DB\n# A atenuação de 11DB é a máxima e permite leituras de 0V a 3,6V\n\n# Configurar a largura do bit (opcional)\nadc.width(ADC.WIDTH_12BIT)  # Opções: ADC.WIDTH_9BIT, ADC.WIDTH_10BIT, ADC.WIDTH_11BIT, ADC.WIDTH_12BIT\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# PWM\n\n# Configurar o pino GPIO onde o PWM será gerado (por exemplo, GPIO15)\npwm_pin = Pin(15)\n\n# Inicializar a saída PWM\npwm = PWM(pwm_pin)\n\n# Configurar a frequência do PWM\npwm.freq(1000)  # 1000 Hz (1 kHz)\n\n# Configurar o duty cycle do PWM (0-1023)\npwm.duty(512)  # 50% do duty cycle\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# Alterar o duty cycle ao longo do tempo e ler o valor do ADC\n\nwhile True:\n    for duty in range(0, 1024, 64):\n        print(duty)\n        pwm.duty(duty)\n        \n        valor_adc = adc.read()\n        valor_uv = adc.read_u16()\n        print("Valor ADC:", valor_adc)\n        print("Valor ADC:", valor_uv)\n        \n        time.sleep(0.1)\n\n"""\nO ESP32 possui múltiplos pinos que podem ser usados como entradas ADC (Conversor Analógico-Digital). Existem duas unidades de ADC, ADC1 e ADC2, com um total de 18 canais ADC disponíveis. Aqui estão os pinos que você pode usar para ADC:\n\nADC1 (8 canais)\nGPIO32 (ADC1_CH4)\n\nGPIO33 (ADC1_CH5)\n\nGPIO34 (ADC1_CH6)\n\nGPIO35 (ADC1_CH7)\n\nGPIO36 (ADC1_CH0)\n\nGPIO37 (ADC1_CH1)\n\nGPIO38 (ADC1_CH2)\n\nGPIO39 (ADC1_CH3)\n\nADC2 (10 canais)\nGPIO0 (ADC2_CH1)\n\nGPIO2 (ADC2_CH2)\n\nGPIO4 (ADC2_CH0)\n\nGPIO12 (ADC2_CH5)\n\nGPIO13 (ADC2_CH4)\n\nGPIO14 (ADC2_CH6)\n\nGPIO15 (ADC2_CH3)\n\nGPIO25 (ADC2_CH8)\n\nGPIO26 (ADC2_CH9)\n\nGPIO27 (ADC2_CH7)\n\nNota:\nADC1 vs ADC2:\n\nADC1: Pode ser usado para leituras ADC normalmente, mesmo durante o uso do WiFi.\n\nADC2: Pode ter conflitos quando o WiFi está ativo, pois compartilha recursos de hardware com o WiFi do ESP32.\n"""', name='Run', argv=[], id='cmd_204', local_cwd='C:\\Users\\lucas')
17:36:01.463 [MainThread] INFO    thonny.plugins.micropython.mp_front: Listing serial ports
17:36:01.468 [MainThread] INFO    thonny: TIME/MODS 0.032 After Run 
17:38:22.542 [MainThread] INFO    thonny: TIME/MODS 141.073 Before Run 
17:38:22.585 [MainThread] INFO    thonny.running: Prepared clean state for executing ToplevelCommand(args=['-c'], args_str='-c $EDITOR_CONTENT', cmd_line='%Run -c $EDITOR_CONTENT', tty_mode=True, source='from machine import ADC, PWM, Pin\nimport time\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# ADC\n\n# Configurar o pino ao qual o sensor está conectado (por exemplo, GPIO 32)\nadc_pin = Pin(32)\n\n# Inicializar o ADC\nadc = ADC(adc_pin)\n\n# Configurar a atenuação (opcional, melhora a leitura em diferentes ranges de tensão)\nadc.atten(ADC.ATTN_11DB)  # Opções: ADC.ATTN_0DB, ADC.ATTN_2_5DB, ADC.ATTN_6DB, ADC.ATTN_11DB\n# A atenuação de 11DB é a máxima e permite leituras de 0V a 3,6V\n\n# Configurar a largura do bit (opcional)\nadc.width(ADC.WIDTH_12BIT)  # Opções: ADC.WIDTH_9BIT, ADC.WIDTH_10BIT, ADC.WIDTH_11BIT, ADC.WIDTH_12BIT\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# PWM\n\n# Configurar o pino GPIO onde o PWM será gerado (por exemplo, GPIO15)\npwm_pin = Pin(15)\n\n# Inicializar a saída PWM\npwm = PWM(pwm_pin)\n\n# Configurar a frequência do PWM\npwm.freq(1000)  # 1000 Hz (1 kHz)\n\n# Configurar o duty cycle do PWM (0-1023)\npwm.duty(512)  # 50% do duty cycle\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# Alterar o duty cycle ao longo do tempo e ler o valor do ADC\n\nwhile True:\n    for duty in range(0, 1024):\n        print(duty)\n        pwm.duty(duty)\n        \n        valor_adc = adc.read()\n        valor_uv = adc.read_u16()\n        print("Valor ADC:", valor_adc)\n        print("Valor ADC:", valor_uv)\n        \n        time.sleep(0.5)\n\n"""\nO ESP32 possui múltiplos pinos que podem ser usados como entradas ADC (Conversor Analógico-Digital). Existem duas unidades de ADC, ADC1 e ADC2, com um total de 18 canais ADC disponíveis. Aqui estão os pinos que você pode usar para ADC:\n\nADC1 (8 canais)\nGPIO32 (ADC1_CH4)\n\nGPIO33 (ADC1_CH5)\n\nGPIO34 (ADC1_CH6)\n\nGPIO35 (ADC1_CH7)\n\nGPIO36 (ADC1_CH0)\n\nGPIO37 (ADC1_CH1)\n\nGPIO38 (ADC1_CH2)\n\nGPIO39 (ADC1_CH3)\n\nADC2 (10 canais)\nGPIO0 (ADC2_CH1)\n\nGPIO2 (ADC2_CH2)\n\nGPIO4 (ADC2_CH0)\n\nGPIO12 (ADC2_CH5)\n\nGPIO13 (ADC2_CH4)\n\nGPIO14 (ADC2_CH6)\n\nGPIO15 (ADC2_CH3)\n\nGPIO25 (ADC2_CH8)\n\nGPIO26 (ADC2_CH9)\n\nGPIO27 (ADC2_CH7)\n\nNota:\nADC1 vs ADC2:\n\nADC1: Pode ser usado para leituras ADC normalmente, mesmo durante o uso do WiFi.\n\nADC2: Pode ter conflitos quando o WiFi está ativo, pois compartilha recursos de hardware com o WiFi do ESP32.\n"""', name='Run', argv=[], id='cmd_213', local_cwd='C:\\Users\\lucas')
17:38:22.585 [MainThread] INFO    thonny.plugins.micropython.mp_front: Listing serial ports
17:38:22.590 [MainThread] INFO    thonny: TIME/MODS 0.049 After Run 
17:38:46.440 [MainThread] INFO    thonny: TIME/MODS 23.850 Before Run 
17:38:46.440 [MainThread] INFO    thonny.running: Trying to execute current but runner is 'running'
17:38:46.866 [MainThread] INFO    thonny.running: Prepared clean state for executing ToplevelCommand(args=['-c'], args_str='-c $EDITOR_CONTENT', cmd_line='%Run -c $EDITOR_CONTENT', tty_mode=True, source='from machine import ADC, PWM, Pin\nimport time\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# ADC\n\n# Configurar o pino ao qual o sensor está conectado (por exemplo, GPIO 32)\nadc_pin = Pin(32)\n\n# Inicializar o ADC\nadc = ADC(adc_pin)\n\n# Configurar a atenuação (opcional, melhora a leitura em diferentes ranges de tensão)\nadc.atten(ADC.ATTN_11DB)  # Opções: ADC.ATTN_0DB, ADC.ATTN_2_5DB, ADC.ATTN_6DB, ADC.ATTN_11DB\n# A atenuação de 11DB é a máxima e permite leituras de 0V a 3,6V\n\n# Configurar a largura do bit (opcional)\nadc.width(ADC.WIDTH_12BIT)  # Opções: ADC.WIDTH_9BIT, ADC.WIDTH_10BIT, ADC.WIDTH_11BIT, ADC.WIDTH_12BIT\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# PWM\n\n# Configurar o pino GPIO onde o PWM será gerado (por exemplo, GPIO15)\npwm_pin = Pin(15)\n\n# Inicializar a saída PWM\npwm = PWM(pwm_pin)\n\n# Configurar a frequência do PWM\npwm.freq(1000)  # 1000 Hz (1 kHz)\n\n# Configurar o duty cycle do PWM (0-1023)\npwm.duty(512)  # 50% do duty cycle\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# Alterar o duty cycle ao longo do tempo e ler o valor do ADC\n\nwhile True:\n    for duty in range(0, 1024):\n        print(duty)\n        pwm.duty(duty)\n        \n        valor_adc = adc.read()\n        valor_uv = adc.read_u16()\n        print("Valor ADC:", valor_adc)\n        print("Valor ADC:", valor_uv)\n        \n        time.sleep(0.1)\n\n"""\nO ESP32 possui múltiplos pinos que podem ser usados como entradas ADC (Conversor Analógico-Digital). Existem duas unidades de ADC, ADC1 e ADC2, com um total de 18 canais ADC disponíveis. Aqui estão os pinos que você pode usar para ADC:\n\nADC1 (8 canais)\nGPIO32 (ADC1_CH4)\n\nGPIO33 (ADC1_CH5)\n\nGPIO34 (ADC1_CH6)\n\nGPIO35 (ADC1_CH7)\n\nGPIO36 (ADC1_CH0)\n\nGPIO37 (ADC1_CH1)\n\nGPIO38 (ADC1_CH2)\n\nGPIO39 (ADC1_CH3)\n\nADC2 (10 canais)\nGPIO0 (ADC2_CH1)\n\nGPIO2 (ADC2_CH2)\n\nGPIO4 (ADC2_CH0)\n\nGPIO12 (ADC2_CH5)\n\nGPIO13 (ADC2_CH4)\n\nGPIO14 (ADC2_CH6)\n\nGPIO15 (ADC2_CH3)\n\nGPIO25 (ADC2_CH8)\n\nGPIO26 (ADC2_CH9)\n\nGPIO27 (ADC2_CH7)\n\nNota:\nADC1 vs ADC2:\n\nADC1: Pode ser usado para leituras ADC normalmente, mesmo durante o uso do WiFi.\n\nADC2: Pode ter conflitos quando o WiFi está ativo, pois compartilha recursos de hardware com o WiFi do ESP32.\n"""', name='Run', argv=[], id='cmd_215', local_cwd='C:\\Users\\lucas')
17:38:46.866 [MainThread] INFO    thonny.plugins.micropython.mp_front: Listing serial ports
17:38:46.871 [MainThread] INFO    thonny: TIME/MODS 0.431 After Run 
17:39:09.037 [MainThread] INFO    thonny: TIME/MODS 22.166 Before Run 
17:39:09.037 [MainThread] INFO    thonny.running: Trying to execute current but runner is 'running'
17:39:09.433 [MainThread] INFO    thonny.running: Prepared clean state for executing ToplevelCommand(args=['-c'], args_str='-c $EDITOR_CONTENT', cmd_line='%Run -c $EDITOR_CONTENT', tty_mode=True, source='from machine import ADC, PWM, Pin\nimport time\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# ADC\n\n# Configurar o pino ao qual o sensor está conectado (por exemplo, GPIO 32)\nadc_pin = Pin(32)\n\n# Inicializar o ADC\nadc = ADC(adc_pin)\n\n# Configurar a atenuação (opcional, melhora a leitura em diferentes ranges de tensão)\nadc.atten(ADC.ATTN_11DB)  # Opções: ADC.ATTN_0DB, ADC.ATTN_2_5DB, ADC.ATTN_6DB, ADC.ATTN_11DB\n# A atenuação de 11DB é a máxima e permite leituras de 0V a 3,6V\n\n# Configurar a largura do bit (opcional)\nadc.width(ADC.WIDTH_12BIT)  # Opções: ADC.WIDTH_9BIT, ADC.WIDTH_10BIT, ADC.WIDTH_11BIT, ADC.WIDTH_12BIT\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# PWM\n\n# Configurar o pino GPIO onde o PWM será gerado (por exemplo, GPIO15)\npwm_pin = Pin(15)\n\n# Inicializar a saída PWM\npwm = PWM(pwm_pin)\n\n# Configurar a frequência do PWM\npwm.freq(1000)  # 1000 Hz (1 kHz)\n\n# Configurar o duty cycle do PWM (0-1023)\npwm.duty(512)  # 50% do duty cycle\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# Alterar o duty cycle ao longo do tempo e ler o valor do ADC\n\nwhile True:\n    for duty in range(0, 1024, 2):\n        print(duty)\n        pwm.duty(duty)\n        \n        valor_adc = adc.read()\n        valor_uv = adc.read_u16()\n        print("Valor ADC:", valor_adc)\n        print("Valor ADC:", valor_uv)\n        \n        time.sleep(0.1)\n\n"""\nO ESP32 possui múltiplos pinos que podem ser usados como entradas ADC (Conversor Analógico-Digital). Existem duas unidades de ADC, ADC1 e ADC2, com um total de 18 canais ADC disponíveis. Aqui estão os pinos que você pode usar para ADC:\n\nADC1 (8 canais)\nGPIO32 (ADC1_CH4)\n\nGPIO33 (ADC1_CH5)\n\nGPIO34 (ADC1_CH6)\n\nGPIO35 (ADC1_CH7)\n\nGPIO36 (ADC1_CH0)\n\nGPIO37 (ADC1_CH1)\n\nGPIO38 (ADC1_CH2)\n\nGPIO39 (ADC1_CH3)\n\nADC2 (10 canais)\nGPIO0 (ADC2_CH1)\n\nGPIO2 (ADC2_CH2)\n\nGPIO4 (ADC2_CH0)\n\nGPIO12 (ADC2_CH5)\n\nGPIO13 (ADC2_CH4)\n\nGPIO14 (ADC2_CH6)\n\nGPIO15 (ADC2_CH3)\n\nGPIO25 (ADC2_CH8)\n\nGPIO26 (ADC2_CH9)\n\nGPIO27 (ADC2_CH7)\n\nNota:\nADC1 vs ADC2:\n\nADC1: Pode ser usado para leituras ADC normalmente, mesmo durante o uso do WiFi.\n\nADC2: Pode ter conflitos quando o WiFi está ativo, pois compartilha recursos de hardware com o WiFi do ESP32.\n"""', name='Run', argv=[], id='cmd_217', local_cwd='C:\\Users\\lucas')
17:39:09.434 [MainThread] INFO    thonny.plugins.micropython.mp_front: Listing serial ports
17:39:09.438 [MainThread] INFO    thonny: TIME/MODS 0.401 After Run 
17:41:34.077 [MainThread] INFO    thonny: TIME/MODS 144.639 Before Run 
17:41:34.147 [MainThread] INFO    thonny.running: Prepared clean state for executing ToplevelCommand(args=['-c'], args_str='-c $EDITOR_CONTENT', cmd_line='%Run -c $EDITOR_CONTENT', tty_mode=True, source='from machine import ADC, PWM, Pin\nimport time\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# ADC\n\n# Configurar o pino ao qual o sensor está conectado (por exemplo, GPIO 32)\nadc_pin = Pin(5)\n\n# Inicializar o ADC\nadc = ADC(adc_pin)\n\n# Configurar a atenuação (opcional, melhora a leitura em diferentes ranges de tensão)\nadc.atten(ADC.ATTN_11DB)  # Opções: ADC.ATTN_0DB, ADC.ATTN_2_5DB, ADC.ATTN_6DB, ADC.ATTN_11DB\n# A atenuação de 11DB é a máxima e permite leituras de 0V a 3,6V\n\n# Configurar a largura do bit (opcional)\nadc.width(ADC.WIDTH_12BIT)  # Opções: ADC.WIDTH_9BIT, ADC.WIDTH_10BIT, ADC.WIDTH_11BIT, ADC.WIDTH_12BIT\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# PWM\n\n# Configurar o pino GPIO onde o PWM será gerado (por exemplo, GPIO15)\npwm_pin = Pin(15)\n\n# Inicializar a saída PWM\npwm = PWM(pwm_pin)\npwm2 = PWM(Pin(2))\n\n# Configurar a frequência do PWM\npwm.freq(1000)  # 1000 Hz (1 kHz)\npwm2.freq(1000)  # 1000 Hz (1 kHz)\n\n# Configurar o duty cycle do PWM (0-1023)\npwm.duty(512)  # 50% do duty cycle\npwm2.duty(512)  # 50% do duty cycle\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# Alterar o duty cycle ao longo do tempo e ler o valor do ADC\n\nwhile True:\n    for duty in range(0, 65535, 2):\n        print(duty)\n        pwm.duty_u16(duty)\n        pwm2.duty_u16(duty)\n        \n        valor_adc = adc.read()\n        valor_uv = adc.read_u16()\n        print("Valor ADC:", valor_adc)\n        print("Valor ADC:", valor_uv)\n        \n        time.sleep(0.1)\n\n"""\nO ESP32 possui múltiplos pinos que podem ser usados como entradas ADC (Conversor Analógico-Digital). Existem duas unidades de ADC, ADC1 e ADC2, com um total de 18 canais ADC disponíveis. Aqui estão os pinos que você pode usar para ADC:\n\nADC1 (8 canais)\nGPIO32 (ADC1_CH4)\n\nGPIO33 (ADC1_CH5)\n\nGPIO34 (ADC1_CH6)\n\nGPIO35 (ADC1_CH7)\n\nGPIO36 (ADC1_CH0)\n\nGPIO37 (ADC1_CH1)\n\nGPIO38 (ADC1_CH2)\n\nGPIO39 (ADC1_CH3)\n\nADC2 (10 canais)\nGPIO0 (ADC2_CH1)\n\nGPIO2 (ADC2_CH2)\n\nGPIO4 (ADC2_CH0)\n\nGPIO12 (ADC2_CH5)\n\nGPIO13 (ADC2_CH4)\n\nGPIO14 (ADC2_CH6)\n\nGPIO15 (ADC2_CH3)\n\nGPIO25 (ADC2_CH8)\n\nGPIO26 (ADC2_CH9)\n\nGPIO27 (ADC2_CH7)\n\nNota:\nADC1 vs ADC2:\n\nADC1: Pode ser usado para leituras ADC normalmente, mesmo durante o uso do WiFi.\n\nADC2: Pode ter conflitos quando o WiFi está ativo, pois compartilha recursos de hardware com o WiFi do ESP32.\n"""', name='Run', argv=[], id='cmd_348', local_cwd='C:\\Users\\lucas')
17:41:34.147 [MainThread] INFO    thonny.plugins.micropython.mp_front: Listing serial ports
17:41:34.152 [MainThread] INFO    thonny: TIME/MODS 0.075 After Run 
17:42:11.558 [MainThread] INFO    thonny: TIME/MODS 37.406 Before Run 
17:42:11.613 [MainThread] INFO    thonny.running: Prepared clean state for executing ToplevelCommand(args=['-c'], args_str='-c $EDITOR_CONTENT', cmd_line='%Run -c $EDITOR_CONTENT', tty_mode=True, source='from machine import ADC, PWM, Pin\nimport time\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# ADC\n\n# Configurar o pino ao qual o sensor está conectado (por exemplo, GPIO 32)\nadc_pin = Pin(32)\n\n# Inicializar o ADC\nadc = ADC(adc_pin)\n\n# Configurar a atenuação (opcional, melhora a leitura em diferentes ranges de tensão)\nadc.atten(ADC.ATTN_11DB)  # Opções: ADC.ATTN_0DB, ADC.ATTN_2_5DB, ADC.ATTN_6DB, ADC.ATTN_11DB\n# A atenuação de 11DB é a máxima e permite leituras de 0V a 3,6V\n\n# Configurar a largura do bit (opcional)\nadc.width(ADC.WIDTH_12BIT)  # Opções: ADC.WIDTH_9BIT, ADC.WIDTH_10BIT, ADC.WIDTH_11BIT, ADC.WIDTH_12BIT\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# PWM\n\n# Configurar o pino GPIO onde o PWM será gerado (por exemplo, GPIO15)\npwm_pin = Pin(15)\n\n# Inicializar a saída PWM\npwm = PWM(pwm_pin)\npwm2 = PWM(Pin(2))\n\n# Configurar a frequência do PWM\npwm.freq(1000)  # 1000 Hz (1 kHz)\npwm2.freq(1000)  # 1000 Hz (1 kHz)\n\n# Configurar o duty cycle do PWM (0-1023)\npwm.duty(512)  # 50% do duty cycle\npwm2.duty(512)  # 50% do duty cycle\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# Alterar o duty cycle ao longo do tempo e ler o valor do ADC\n\nwhile True:\n    for duty in range(0, 65535, 2):\n        print(duty)\n        pwm.duty_u16(duty)\n        pwm2.duty_u16(duty)\n        \n        valor_adc = adc.read()\n        valor_uv = adc.read_u16()\n        print("Valor ADC:", valor_adc)\n        print("Valor ADC:", valor_uv)\n        \n        time.sleep(0.1)\n\n"""\nO ESP32 possui múltiplos pinos que podem ser usados como entradas ADC (Conversor Analógico-Digital). Existem duas unidades de ADC, ADC1 e ADC2, com um total de 18 canais ADC disponíveis. Aqui estão os pinos que você pode usar para ADC:\n\nADC1 (8 canais)\nGPIO32 (ADC1_CH4)\n\nGPIO33 (ADC1_CH5)\n\nGPIO34 (ADC1_CH6)\n\nGPIO35 (ADC1_CH7)\n\nGPIO36 (ADC1_CH0)\n\nGPIO37 (ADC1_CH1)\n\nGPIO38 (ADC1_CH2)\n\nGPIO39 (ADC1_CH3)\n\nADC2 (10 canais)\nGPIO0 (ADC2_CH1)\n\nGPIO2 (ADC2_CH2)\n\nGPIO4 (ADC2_CH0)\n\nGPIO12 (ADC2_CH5)\n\nGPIO13 (ADC2_CH4)\n\nGPIO14 (ADC2_CH6)\n\nGPIO15 (ADC2_CH3)\n\nGPIO25 (ADC2_CH8)\n\nGPIO26 (ADC2_CH9)\n\nGPIO27 (ADC2_CH7)\n\nNota:\nADC1 vs ADC2:\n\nADC1: Pode ser usado para leituras ADC normalmente, mesmo durante o uso do WiFi.\n\nADC2: Pode ter conflitos quando o WiFi está ativo, pois compartilha recursos de hardware com o WiFi do ESP32.\n"""', name='Run', argv=[], id='cmd_355', local_cwd='C:\\Users\\lucas')
17:42:11.613 [MainThread] INFO    thonny.plugins.micropython.mp_front: Listing serial ports
17:42:11.618 [MainThread] INFO    thonny: TIME/MODS 0.060 After Run 
17:42:52.517 [MainThread] INFO    thonny: TIME/MODS 40.900 Before Run 
17:42:52.579 [MainThread] INFO    thonny.running: Prepared clean state for executing ToplevelCommand(args=['-c'], args_str='-c $EDITOR_CONTENT', cmd_line='%Run -c $EDITOR_CONTENT', tty_mode=True, source='from machine import ADC, PWM, Pin\nimport time\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# ADC\n\n# Configurar o pino ao qual o sensor está conectado (por exemplo, GPIO 32)\nadc_pin = Pin(32)\n\n# Inicializar o ADC\nadc = ADC(adc_pin)\n\n# Configurar a atenuação (opcional, melhora a leitura em diferentes ranges de tensão)\nadc.atten(ADC.ATTN_11DB)  # Opções: ADC.ATTN_0DB, ADC.ATTN_2_5DB, ADC.ATTN_6DB, ADC.ATTN_11DB\n# A atenuação de 11DB é a máxima e permite leituras de 0V a 3,6V\n\n# Configurar a largura do bit (opcional)\nadc.width(ADC.WIDTH_12BIT)  # Opções: ADC.WIDTH_9BIT, ADC.WIDTH_10BIT, ADC.WIDTH_11BIT, ADC.WIDTH_12BIT\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# PWM\n\n# Configurar o pino GPIO onde o PWM será gerado (por exemplo, GPIO15)\npwm_pin = Pin(15)\n\n# Inicializar a saída PWM\npwm = PWM(pwm_pin)\npwm2 = PWM(Pin(2))\n\n# Configurar a frequência do PWM\npwm.freq(1000)  # 1000 Hz (1 kHz)\npwm2.freq(1000)  # 1000 Hz (1 kHz)\n\n# Configurar o duty cycle do PWM (0-1023)\npwm.duty(512)  # 50% do duty cycle\npwm2.duty(512)  # 50% do duty cycle\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# Alterar o duty cycle ao longo do tempo e ler o valor do ADC\n\nwhile True:\n    for duty in range(0, 65535, 50):\n        print(duty)\n        pwm.duty_u16(duty)\n        pwm2.duty_u16(duty)\n        \n        valor_adc = adc.read()\n        valor_uv = adc.read_u16()\n        print("Valor ADC:", valor_adc)\n        print("Valor ADC:", valor_uv)\n        \n        time.sleep(0.1)\n\n"""\nO ESP32 possui múltiplos pinos que podem ser usados como entradas ADC (Conversor Analógico-Digital). Existem duas unidades de ADC, ADC1 e ADC2, com um total de 18 canais ADC disponíveis. Aqui estão os pinos que você pode usar para ADC:\n\nADC1 (8 canais)\nGPIO32 (ADC1_CH4)\n\nGPIO33 (ADC1_CH5)\n\nGPIO34 (ADC1_CH6)\n\nGPIO35 (ADC1_CH7)\n\nGPIO36 (ADC1_CH0)\n\nGPIO37 (ADC1_CH1)\n\nGPIO38 (ADC1_CH2)\n\nGPIO39 (ADC1_CH3)\n\nADC2 (10 canais)\nGPIO0 (ADC2_CH1)\n\nGPIO2 (ADC2_CH2)\n\nGPIO4 (ADC2_CH0)\n\nGPIO12 (ADC2_CH5)\n\nGPIO13 (ADC2_CH4)\n\nGPIO14 (ADC2_CH6)\n\nGPIO15 (ADC2_CH3)\n\nGPIO25 (ADC2_CH8)\n\nGPIO26 (ADC2_CH9)\n\nGPIO27 (ADC2_CH7)\n\nNota:\nADC1 vs ADC2:\n\nADC1: Pode ser usado para leituras ADC normalmente, mesmo durante o uso do WiFi.\n\nADC2: Pode ter conflitos quando o WiFi está ativo, pois compartilha recursos de hardware com o WiFi do ESP32.\n"""', name='Run', argv=[], id='cmd_362', local_cwd='C:\\Users\\lucas')
17:42:52.579 [MainThread] INFO    thonny.plugins.micropython.mp_front: Listing serial ports
17:42:52.585 [MainThread] INFO    thonny: TIME/MODS 0.068 After Run 
17:43:28.762 [MainThread] INFO    thonny.running: Killing backend process
17:43:28.774 [Thread-12 (_listen_stdout)] INFO    thonny.running: Reader got EOF
17:43:28.872 [MainThread] INFO    thonny.shell: BaseShellText._on_backend_terminated
17:43:28.882 [MainThread] INFO    thonny.running: Starting the backend: ['D:\\Lucas Ribeiro\\Programas\\ESP32\\MicroPython\\thonny-4.1.7-windows-portable\\python.exe', '-s', '-u', '-B', 'D:\\Lucas Ribeiro\\Programas\\ESP32\\MicroPython\\thonny-4.1.7-windows-portable\\lib\\site-packages\\thonny\\plugins\\esp\\esp_back.py', "{'clean': True, 'port': 'COM5', 'dtr': None, 'rts': None, 'submit_mode': None, 'interrupt_on_connect': True, 'write_block_size': None, 'write_block_delay': None, 'proxy_class': 'ESP32Proxy', 'sync_time': True, 'validate_time': False, 'local_rtc': True}"] C:\Users\lucas
17:43:29.046 [MainThread] INFO    thonny.shell: BaseShellText.restart(False)
17:43:29.069 [MainThread] INFO    thonny.plugins.micropython.mp_front: Listing serial ports
17:43:32.686 [MainThread] INFO    thonny: TIME/MODS 40.101 Before Run 
17:43:32.686 [MainThread] INFO    thonny.running: Trying to execute current but runner is 'running'
17:43:33.539 [MainThread] INFO    thonny.plugins.micropython.mp_front: Listing serial ports
17:43:33.621 [MainThread] INFO    thonny.running: Prepared clean state for executing ToplevelCommand(args=['-c'], args_str='-c $EDITOR_CONTENT', cmd_line='%Run -c $EDITOR_CONTENT', tty_mode=True, source='from machine import ADC, PWM, Pin\nimport time\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# ADC\n\n# Configurar o pino ao qual o sensor está conectado (por exemplo, GPIO 32)\nadc_pin = Pin(32)\n\n# Inicializar o ADC\nadc = ADC(adc_pin)\n\n# Configurar a atenuação (opcional, melhora a leitura em diferentes ranges de tensão)\nadc.atten(ADC.ATTN_11DB)  # Opções: ADC.ATTN_0DB, ADC.ATTN_2_5DB, ADC.ATTN_6DB, ADC.ATTN_11DB\n# A atenuação de 11DB é a máxima e permite leituras de 0V a 3,6V\n\n# Configurar a largura do bit (opcional)\nadc.width(ADC.WIDTH_12BIT)  # Opções: ADC.WIDTH_9BIT, ADC.WIDTH_10BIT, ADC.WIDTH_11BIT, ADC.WIDTH_12BIT\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# PWM\n\n# Configurar o pino GPIO onde o PWM será gerado (por exemplo, GPIO15)\npwm_pin = Pin(15)\n\n# Inicializar a saída PWM\npwm = PWM(pwm_pin)\npwm2 = PWM(Pin(2))\n\n# Configurar a frequência do PWM\npwm.freq(1000)  # 1000 Hz (1 kHz)\npwm2.freq(1000)  # 1000 Hz (1 kHz)\n\n# Configurar o duty cycle do PWM (0-1023)\npwm.duty(512)  # 50% do duty cycle\npwm2.duty(512)  # 50% do duty cycle\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# Alterar o duty cycle ao longo do tempo e ler o valor do ADC\n\nwhile True:\n    for duty in range(0, 65535, 5000):\n        print(duty)\n        pwm.duty_u16(duty)\n        pwm2.duty_u16(duty)\n        \n        valor_adc = adc.read()\n        valor_uv = adc.read_u16()\n        print("Valor ADC:", valor_adc)\n        print("Valor ADC:", valor_uv)\n        \n        time.sleep(0.1)\n\n"""\nO ESP32 possui múltiplos pinos que podem ser usados como entradas ADC (Conversor Analógico-Digital). Existem duas unidades de ADC, ADC1 e ADC2, com um total de 18 canais ADC disponíveis. Aqui estão os pinos que você pode usar para ADC:\n\nADC1 (8 canais)\nGPIO32 (ADC1_CH4)\n\nGPIO33 (ADC1_CH5)\n\nGPIO34 (ADC1_CH6)\n\nGPIO35 (ADC1_CH7)\n\nGPIO36 (ADC1_CH0)\n\nGPIO37 (ADC1_CH1)\n\nGPIO38 (ADC1_CH2)\n\nGPIO39 (ADC1_CH3)\n\nADC2 (10 canais)\nGPIO0 (ADC2_CH1)\n\nGPIO2 (ADC2_CH2)\n\nGPIO4 (ADC2_CH0)\n\nGPIO12 (ADC2_CH5)\n\nGPIO13 (ADC2_CH4)\n\nGPIO14 (ADC2_CH6)\n\nGPIO15 (ADC2_CH3)\n\nGPIO25 (ADC2_CH8)\n\nGPIO26 (ADC2_CH9)\n\nGPIO27 (ADC2_CH7)\n\nNota:\nADC1 vs ADC2:\n\nADC1: Pode ser usado para leituras ADC normalmente, mesmo durante o uso do WiFi.\n\nADC2: Pode ter conflitos quando o WiFi está ativo, pois compartilha recursos de hardware com o WiFi do ESP32.\n"""', name='Run', argv=[], id='cmd_364', local_cwd='C:\\Users\\lucas')
17:43:33.622 [MainThread] INFO    thonny: TIME/MODS 0.936 After Run 
17:43:44.052 [MainThread] INFO    thonny.running: Killing backend process
17:43:44.079 [Thread-14 (_listen_stdout)] INFO    thonny.running: Reader got EOF
17:43:44.166 [MainThread] INFO    thonny.shell: BaseShellText._on_backend_terminated
17:43:44.175 [MainThread] INFO    thonny.running: Starting the backend: ['D:\\Lucas Ribeiro\\Programas\\ESP32\\MicroPython\\thonny-4.1.7-windows-portable\\python.exe', '-s', '-u', '-B', 'D:\\Lucas Ribeiro\\Programas\\ESP32\\MicroPython\\thonny-4.1.7-windows-portable\\lib\\site-packages\\thonny\\plugins\\esp\\esp_back.py', "{'clean': True, 'port': 'COM5', 'dtr': None, 'rts': None, 'submit_mode': None, 'interrupt_on_connect': True, 'write_block_size': None, 'write_block_delay': None, 'proxy_class': 'ESP32Proxy', 'sync_time': True, 'validate_time': False, 'local_rtc': True}"] C:\Users\lucas
17:43:44.339 [MainThread] INFO    thonny.shell: BaseShellText.restart(False)
17:43:44.361 [MainThread] INFO    thonny.plugins.micropython.mp_front: Listing serial ports
17:43:48.427 [MainThread] INFO    thonny: TIME/MODS 14.806 Before Run 
17:43:48.427 [MainThread] INFO    thonny.running: Trying to execute current but runner is 'running'
17:43:49.226 [MainThread] INFO    thonny.plugins.micropython.mp_front: Listing serial ports
17:43:49.274 [MainThread] INFO    thonny.running: Prepared clean state for executing ToplevelCommand(args=['-c'], args_str='-c $EDITOR_CONTENT', cmd_line='%Run -c $EDITOR_CONTENT', tty_mode=True, source='from machine import ADC, PWM, Pin\nimport time\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# ADC\n\n# Configurar o pino ao qual o sensor está conectado (por exemplo, GPIO 32)\nadc_pin = Pin(32)\n\n# Inicializar o ADC\nadc = ADC(adc_pin)\n\n# Configurar a atenuação (opcional, melhora a leitura em diferentes ranges de tensão)\nadc.atten(ADC.ATTN_11DB)  # Opções: ADC.ATTN_0DB, ADC.ATTN_2_5DB, ADC.ATTN_6DB, ADC.ATTN_11DB\n# A atenuação de 11DB é a máxima e permite leituras de 0V a 3,6V\n\n# Configurar a largura do bit (opcional)\nadc.width(ADC.WIDTH_12BIT)  # Opções: ADC.WIDTH_9BIT, ADC.WIDTH_10BIT, ADC.WIDTH_11BIT, ADC.WIDTH_12BIT\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# PWM\n\n# Configurar o pino GPIO onde o PWM será gerado (por exemplo, GPIO15)\npwm_pin = Pin(15)\n\n# Inicializar a saída PWM\npwm = PWM(pwm_pin)\npwm2 = PWM(Pin(2))\n\n# Configurar a frequência do PWM\npwm.freq(1000)  # 1000 Hz (1 kHz)\npwm2.freq(1000)  # 1000 Hz (1 kHz)\n\n# Configurar o duty cycle do PWM (0-1023)\npwm.duty(512)  # 50% do duty cycle\npwm2.duty(512)  # 50% do duty cycle\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# Alterar o duty cycle ao longo do tempo e ler o valor do ADC\n\nwhile True:\n    for duty in range(0, 65535, 5000):\n        print(duty)\n        pwm.duty_u16(duty)\n        pwm2.duty_u16(duty)\n        \n        valor_adc = adc.read()\n        valor_uv = adc.read_u16()\n        print("Valor ADC:", valor_adc)\n        print("Valor ADC:", valor_uv)\n        \n        time.sleep(0.1)\n\n"""\nO ESP32 possui múltiplos pinos que podem ser usados como entradas ADC (Conversor Analógico-Digital). Existem duas unidades de ADC, ADC1 e ADC2, com um total de 18 canais ADC disponíveis. Aqui estão os pinos que você pode usar para ADC:\n\nADC1 (8 canais)\nGPIO32 (ADC1_CH4)\n\nGPIO33 (ADC1_CH5)\n\nGPIO34 (ADC1_CH6)\n\nGPIO35 (ADC1_CH7)\n\nGPIO36 (ADC1_CH0)\n\nGPIO37 (ADC1_CH1)\n\nGPIO38 (ADC1_CH2)\n\nGPIO39 (ADC1_CH3)\n\nADC2 (10 canais)\nGPIO0 (ADC2_CH1)\n\nGPIO2 (ADC2_CH2)\n\nGPIO4 (ADC2_CH0)\n\nGPIO12 (ADC2_CH5)\n\nGPIO13 (ADC2_CH4)\n\nGPIO14 (ADC2_CH6)\n\nGPIO15 (ADC2_CH3)\n\nGPIO25 (ADC2_CH8)\n\nGPIO26 (ADC2_CH9)\n\nGPIO27 (ADC2_CH7)\n\nNota:\nADC1 vs ADC2:\n\nADC1: Pode ser usado para leituras ADC normalmente, mesmo durante o uso do WiFi.\n\nADC2: Pode ter conflitos quando o WiFi está ativo, pois compartilha recursos de hardware com o WiFi do ESP32.\n"""', name='Run', argv=[], id='cmd_366', local_cwd='C:\\Users\\lucas')
17:43:49.274 [MainThread] INFO    thonny: TIME/MODS 0.846 After Run 
17:44:57.352 [MainThread] INFO    thonny: TIME/MODS 68.079 Before Run 
17:44:57.396 [MainThread] INFO    thonny.running: Prepared clean state for executing ToplevelCommand(args=['-c'], args_str='-c $EDITOR_CONTENT', cmd_line='%Run -c $EDITOR_CONTENT', tty_mode=True, source='from machine import ADC, PWM, Pin\nimport time\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# ADC\n\n# Configurar o pino ao qual o sensor está conectado (por exemplo, GPIO 32)\nadc_pin = Pin(4)\n\n# Inicializar o ADC\nadc = ADC(adc_pin)\n\n# Configurar a atenuação (opcional, melhora a leitura em diferentes ranges de tensão)\nadc.atten(ADC.ATTN_11DB)  # Opções: ADC.ATTN_0DB, ADC.ATTN_2_5DB, ADC.ATTN_6DB, ADC.ATTN_11DB\n# A atenuação de 11DB é a máxima e permite leituras de 0V a 3,6V\n\n# Configurar a largura do bit (opcional)\nadc.width(ADC.WIDTH_12BIT)  # Opções: ADC.WIDTH_9BIT, ADC.WIDTH_10BIT, ADC.WIDTH_11BIT, ADC.WIDTH_12BIT\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# PWM\n\n# Configurar o pino GPIO onde o PWM será gerado (por exemplo, GPIO15)\npwm_pin = Pin(15)\n\n# Inicializar a saída PWM\npwm = PWM(pwm_pin)\npwm2 = PWM(Pin(2))\n\n# Configurar a frequência do PWM\npwm.freq(1000)  # 1000 Hz (1 kHz)\npwm2.freq(1000)  # 1000 Hz (1 kHz)\n\n# Configurar o duty cycle do PWM (0-1023)\npwm.duty(512)  # 50% do duty cycle\npwm2.duty(512)  # 50% do duty cycle\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# Alterar o duty cycle ao longo do tempo e ler o valor do ADC\n\nwhile True:\n    for duty in range(0, 65535, 5000):\n        print(duty)\n        pwm.duty_u16(duty)\n        pwm2.duty_u16(duty)\n        \n        valor_adc = adc.read()\n        valor_uv = adc.read_u16()\n        print("Valor ADC:", valor_adc)\n        print("Valor ADC:", valor_uv)\n        \n        time.sleep(0.1)\n\n"""\nO ESP32 possui múltiplos pinos que podem ser usados como entradas ADC (Conversor Analógico-Digital). Existem duas unidades de ADC, ADC1 e ADC2, com um total de 18 canais ADC disponíveis. Aqui estão os pinos que você pode usar para ADC:\n\nADC1 (8 canais)\nGPIO32 (ADC1_CH4)\n\nGPIO33 (ADC1_CH5)\n\nGPIO34 (ADC1_CH6)\n\nGPIO35 (ADC1_CH7)\n\nGPIO36 (ADC1_CH0)\n\nGPIO37 (ADC1_CH1)\n\nGPIO38 (ADC1_CH2)\n\nGPIO39 (ADC1_CH3)\n\nADC2 (10 canais)\nGPIO0 (ADC2_CH1)\n\nGPIO2 (ADC2_CH2)\n\nGPIO4 (ADC2_CH0)\n\nGPIO12 (ADC2_CH5)\n\nGPIO13 (ADC2_CH4)\n\nGPIO14 (ADC2_CH6)\n\nGPIO15 (ADC2_CH3)\n\nGPIO25 (ADC2_CH8)\n\nGPIO26 (ADC2_CH9)\n\nGPIO27 (ADC2_CH7)\n\nNota:\nADC1 vs ADC2:\n\nADC1: Pode ser usado para leituras ADC normalmente, mesmo durante o uso do WiFi.\n\nADC2: Pode ter conflitos quando o WiFi está ativo, pois compartilha recursos de hardware com o WiFi do ESP32.\n"""', name='Run', argv=[], id='cmd_372', local_cwd='C:\\Users\\lucas')
17:44:57.396 [MainThread] INFO    thonny.plugins.micropython.mp_front: Listing serial ports
17:44:57.401 [MainThread] INFO    thonny: TIME/MODS 0.049 After Run 
17:45:12.602 [MainThread] INFO    thonny: TIME/MODS 15.200 Before Run 
17:45:12.602 [MainThread] INFO    thonny.running: Trying to execute current but runner is 'running'
17:45:12.969 [MainThread] INFO    thonny.running: Prepared clean state for executing ToplevelCommand(args=['-c'], args_str='-c $EDITOR_CONTENT', cmd_line='%Run -c $EDITOR_CONTENT', tty_mode=True, source='from machine import ADC, PWM, Pin\nimport time\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# ADC\n\n# Configurar o pino ao qual o sensor está conectado (por exemplo, GPIO 32)\nadc_pin = Pin(4)\n\n# Inicializar o ADC\nadc = ADC(adc_pin)\n\n# Configurar a atenuação (opcional, melhora a leitura em diferentes ranges de tensão)\nadc.atten(ADC.ATTN_11DB)  # Opções: ADC.ATTN_0DB, ADC.ATTN_2_5DB, ADC.ATTN_6DB, ADC.ATTN_11DB\n# A atenuação de 11DB é a máxima e permite leituras de 0V a 3,6V\n\n# Configurar a largura do bit (opcional)\nadc.width(ADC.WIDTH_12BIT)  # Opções: ADC.WIDTH_9BIT, ADC.WIDTH_10BIT, ADC.WIDTH_11BIT, ADC.WIDTH_12BIT\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# PWM\n\n# Configurar o pino GPIO onde o PWM será gerado (por exemplo, GPIO15)\npwm_pin = Pin(15)\n\n# Inicializar a saída PWM\npwm = PWM(pwm_pin)\npwm2 = PWM(Pin(2))\n\n# Configurar a frequência do PWM\npwm.freq(1000)  # 1000 Hz (1 kHz)\npwm2.freq(1000)  # 1000 Hz (1 kHz)\n\n# Configurar o duty cycle do PWM (0-1023)\npwm.duty(512)  # 50% do duty cycle\npwm2.duty(512)  # 50% do duty cycle\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# Alterar o duty cycle ao longo do tempo e ler o valor do ADC\n\nwhile True:\n    for duty in range(0, 65535, 500):\n        print(duty)\n        pwm.duty_u16(duty)\n        pwm2.duty_u16(duty)\n        \n        valor_adc = adc.read()\n        valor_uv = adc.read_u16()\n        print("Valor ADC:", valor_adc)\n        print("Valor ADC:", valor_uv)\n        \n        time.sleep(0.1)\n\n"""\nO ESP32 possui múltiplos pinos que podem ser usados como entradas ADC (Conversor Analógico-Digital). Existem duas unidades de ADC, ADC1 e ADC2, com um total de 18 canais ADC disponíveis. Aqui estão os pinos que você pode usar para ADC:\n\nADC1 (8 canais)\nGPIO32 (ADC1_CH4)\n\nGPIO33 (ADC1_CH5)\n\nGPIO34 (ADC1_CH6)\n\nGPIO35 (ADC1_CH7)\n\nGPIO36 (ADC1_CH0)\n\nGPIO37 (ADC1_CH1)\n\nGPIO38 (ADC1_CH2)\n\nGPIO39 (ADC1_CH3)\n\nADC2 (10 canais)\nGPIO0 (ADC2_CH1)\n\nGPIO2 (ADC2_CH2)\n\nGPIO4 (ADC2_CH0)\n\nGPIO12 (ADC2_CH5)\n\nGPIO13 (ADC2_CH4)\n\nGPIO14 (ADC2_CH6)\n\nGPIO15 (ADC2_CH3)\n\nGPIO25 (ADC2_CH8)\n\nGPIO26 (ADC2_CH9)\n\nGPIO27 (ADC2_CH7)\n\nNota:\nADC1 vs ADC2:\n\nADC1: Pode ser usado para leituras ADC normalmente, mesmo durante o uso do WiFi.\n\nADC2: Pode ter conflitos quando o WiFi está ativo, pois compartilha recursos de hardware com o WiFi do ESP32.\n"""', name='Run', argv=[], id='cmd_374', local_cwd='C:\\Users\\lucas')
17:45:12.970 [MainThread] INFO    thonny.plugins.micropython.mp_front: Listing serial ports
17:45:12.974 [MainThread] INFO    thonny: TIME/MODS 0.372 After Run 
17:47:27.909 [MainThread] INFO    thonny: TIME/MODS 134.935 Before Run 
17:47:27.970 [MainThread] INFO    thonny.running: Prepared clean state for executing ToplevelCommand(args=['-c'], args_str='-c $EDITOR_CONTENT', cmd_line='%Run -c $EDITOR_CONTENT', tty_mode=True, source='from machine import ADC, PWM, Pin\nimport time\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# ADC\n\n# Configurar o pino ao qual o sensor está conectado (por exemplo, GPIO 32)\nadc_pin = Pin(4, mode=Pin.IN)\n\n# Inicializar o ADC\nadc = ADC(adc_pin)\n\n# Configurar a atenuação (opcional, melhora a leitura em diferentes ranges de tensão)\nadc.atten(ADC.ATTN_11DB)  # Opções: ADC.ATTN_0DB, ADC.ATTN_2_5DB, ADC.ATTN_6DB, ADC.ATTN_11DB\n# A atenuação de 11DB é a máxima e permite leituras de 0V a 3,6V\n\n# Configurar a largura do bit (opcional)\nadc.width(ADC.WIDTH_12BIT)  # Opções: ADC.WIDTH_9BIT, ADC.WIDTH_10BIT, ADC.WIDTH_11BIT, ADC.WIDTH_12BIT\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# PWM\n\n# Configurar o pino GPIO onde o PWM será gerado (por exemplo, GPIO15)\npwm_pin = Pin(15)\n\n# Inicializar a saída PWM\npwm = PWM(pwm_pin)\npwm2 = PWM(Pin(2))\n\n# Configurar a frequência do PWM\npwm.freq(1000)  # 1000 Hz (1 kHz)\npwm2.freq(1000)  # 1000 Hz (1 kHz)\n\n# Configurar o duty cycle do PWM (0-1023)\npwm.duty(512)  # 50% do duty cycle\npwm2.duty(512)  # 50% do duty cycle\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# Alterar o duty cycle ao longo do tempo e ler o valor do ADC\n\nwhile True:\n    for duty in range(0, 65535, 500):\n        print(duty)\n        pwm.duty_u16(duty)\n        pwm2.duty_u16(duty)\n        \n        valor_adc = adc.read()\n        valor_uv = adc.read_u16()\n        print("Valor ADC:", valor_adc)\n        print("Valor ADC:", valor_uv)\n        \n        time.sleep(0.1)\n\n"""\nO ESP32 possui múltiplos pinos que podem ser usados como entradas ADC (Conversor Analógico-Digital). Existem duas unidades de ADC, ADC1 e ADC2, com um total de 18 canais ADC disponíveis. Aqui estão os pinos que você pode usar para ADC:\n\nADC1 (8 canais)\nGPIO32 (ADC1_CH4)\n\nGPIO33 (ADC1_CH5)\n\nGPIO34 (ADC1_CH6)\n\nGPIO35 (ADC1_CH7)\n\nGPIO36 (ADC1_CH0)\n\nGPIO37 (ADC1_CH1)\n\nGPIO38 (ADC1_CH2)\n\nGPIO39 (ADC1_CH3)\n\nADC2 (10 canais)\nGPIO0 (ADC2_CH1)\n\nGPIO2 (ADC2_CH2)\n\nGPIO4 (ADC2_CH0)\n\nGPIO12 (ADC2_CH5)\n\nGPIO13 (ADC2_CH4)\n\nGPIO14 (ADC2_CH6)\n\nGPIO15 (ADC2_CH3)\n\nGPIO25 (ADC2_CH8)\n\nGPIO26 (ADC2_CH9)\n\nGPIO27 (ADC2_CH7)\n\nNota:\nADC1 vs ADC2:\n\nADC1: Pode ser usado para leituras ADC normalmente, mesmo durante o uso do WiFi.\n\nADC2: Pode ter conflitos quando o WiFi está ativo, pois compartilha recursos de hardware com o WiFi do ESP32.\n"""', name='Run', argv=[], id='cmd_406', local_cwd='C:\\Users\\lucas')
17:47:27.970 [MainThread] INFO    thonny.plugins.micropython.mp_front: Listing serial ports
17:47:27.975 [MainThread] INFO    thonny: TIME/MODS 0.066 After Run 
17:50:14.016 [MainThread] INFO    thonny: TIME/MODS 166.041 Before Run 
17:50:14.020 [MainThread] INFO    thonny.running: Prepared clean state for executing ToplevelCommand(args=['-c'], args_str='-c $EDITOR_CONTENT', cmd_line='%Run -c $EDITOR_CONTENT', tty_mode=True, source='from machine import ADC, PWM, Pin\nimport time\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# ADC\n\n# Configurar o pino ao qual o sensor está conectado (por exemplo, GPIO 32)\nadc_pin = Pin(4, mode=Pin.IN)\n\n# Inicializar o ADC\nadc = ADC(adc_pin)\n\n# Configurar a atenuação (opcional, melhora a leitura em diferentes ranges de tensão)\nadc.atten(ADC.ATTN_11DB)  # Opções: ADC.ATTN_0DB, ADC.ATTN_2_5DB, ADC.ATTN_6DB, ADC.ATTN_11DB\n# A atenuação de 11DB é a máxima e permite leituras de 0V a 3,6V\n\n# Configurar a largura do bit (opcional)\nadc.width(ADC.WIDTH_12BIT)  # Opções: ADC.WIDTH_9BIT, ADC.WIDTH_10BIT, ADC.WIDTH_11BIT, ADC.WIDTH_12BIT\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# PWM\n\n# Configurar o pino GPIO onde o PWM será gerado (por exemplo, GPIO15)\npwm_pin = Pin(15)\n\n# Inicializar a saída PWM\npwm = PWM(pwm_pin)\npwm2 = PWM(Pin(2))\n\n# Configurar a frequência do PWM\npwm.freq(1000)  # 1000 Hz (1 kHz)\npwm2.freq(1000)  # 1000 Hz (1 kHz)\n\n# Configurar o duty cycle do PWM (0-1023)\npwm.duty(512)  # 50% do duty cycle\npwm2.duty(512)  # 50% do duty cycle\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# Alterar o duty cycle ao longo do tempo e ler o valor do ADC\n\nwhile True:\n    for duty in range(0, 65535, 500):\n        print(duty)\n        pwm.duty_u16(duty)\n        pwm2.duty_u16(duty)\n        \n        valor_adc = adc.read()\n        valor_uv = adc.read_u16()\n        print("Valor ADC:", valor_adc)\n        print("Valor ADC:", valor_uv)\n        \n        time.sleep(0.1)\n\n"""\nO ESP32 possui múltiplos pinos que podem ser usados como entradas ADC (Conversor Analógico-Digital). Existem duas unidades de ADC, ADC1 e ADC2, com um total de 18 canais ADC disponíveis. Aqui estão os pinos que você pode usar para ADC:\n\nADC1 (8 canais)\nGPIO32 (ADC1_CH4)\n\nGPIO33 (ADC1_CH5)\n\nGPIO34 (ADC1_CH6)\n\nGPIO35 (ADC1_CH7)\n\nGPIO36 (ADC1_CH0)\n\nGPIO37 (ADC1_CH1)\n\nGPIO38 (ADC1_CH2)\n\nGPIO39 (ADC1_CH3)\n\nADC2 (10 canais)\nGPIO0 (ADC2_CH1)\n\nGPIO2 (ADC2_CH2)\n\nGPIO4 (ADC2_CH0)\n\nGPIO12 (ADC2_CH5)\n\nGPIO13 (ADC2_CH4)\n\nGPIO14 (ADC2_CH6)\n\nGPIO15 (ADC2_CH3)\n\nGPIO25 (ADC2_CH8)\n\nGPIO26 (ADC2_CH9)\n\nGPIO27 (ADC2_CH7)\n\nNota:\nADC1 vs ADC2:\n\nADC1: Pode ser usado para leituras ADC normalmente, mesmo durante o uso do WiFi.\n\nADC2: Pode ter conflitos quando o WiFi está ativo, pois compartilha recursos de hardware com o WiFi do ESP32.\n"""', name='Run', argv=[], id='cmd_408', local_cwd='C:\\Users\\lucas')
17:50:14.021 [MainThread] INFO    thonny.plugins.micropython.mp_front: Listing serial ports
17:50:14.026 [MainThread] INFO    thonny: TIME/MODS 0.010 After Run 
17:50:25.617 [MainThread] INFO    thonny.running: Killing backend process
17:50:25.645 [Thread-16 (_listen_stdout)] INFO    thonny.running: Reader got EOF
17:50:25.724 [MainThread] INFO    thonny.shell: BaseShellText._on_backend_terminated
17:50:25.735 [MainThread] INFO    thonny.running: Starting the backend: ['D:\\Lucas Ribeiro\\Programas\\ESP32\\MicroPython\\thonny-4.1.7-windows-portable\\python.exe', '-s', '-u', '-B', 'D:\\Lucas Ribeiro\\Programas\\ESP32\\MicroPython\\thonny-4.1.7-windows-portable\\lib\\site-packages\\thonny\\plugins\\esp\\esp_back.py', "{'clean': True, 'port': 'COM5', 'dtr': None, 'rts': None, 'submit_mode': None, 'interrupt_on_connect': True, 'write_block_size': None, 'write_block_delay': None, 'proxy_class': 'ESP32Proxy', 'sync_time': True, 'validate_time': False, 'local_rtc': True}"] C:\Users\lucas
17:50:25.894 [MainThread] INFO    thonny.shell: BaseShellText.restart(False)
17:50:25.916 [MainThread] INFO    thonny.plugins.micropython.mp_front: Listing serial ports
17:50:35.520 [MainThread] INFO    thonny: TIME/MODS 21.494 Before Run 
17:50:35.520 [MainThread] INFO    thonny.running: Trying to execute current but runner is 'running'
17:50:36.372 [MainThread] INFO    thonny.plugins.micropython.mp_front: Listing serial ports
17:50:36.462 [MainThread] INFO    thonny.running: Prepared clean state for executing ToplevelCommand(args=['-c'], args_str='-c $EDITOR_CONTENT', cmd_line='%Run -c $EDITOR_CONTENT', tty_mode=True, source='from machine import ADC, PWM, Pin\nimport time\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# ADC\n\n# Configurar o pino ao qual o sensor está conectado (por exemplo, GPIO 32)\nadc_pin = Pin(4, mode=Pin.IN)\n\n# Inicializar o ADC\nadc = ADC(adc_pin)\n\n# Configurar a atenuação (opcional, melhora a leitura em diferentes ranges de tensão)\nadc.atten(ADC.ATTN_11DB)  # Opções: ADC.ATTN_0DB, ADC.ATTN_2_5DB, ADC.ATTN_6DB, ADC.ATTN_11DB\n# A atenuação de 11DB é a máxima e permite leituras de 0V a 3,6V\n\n# Configurar a largura do bit (opcional)\nadc.width(ADC.WIDTH_12BIT)  # Opções: ADC.WIDTH_9BIT, ADC.WIDTH_10BIT, ADC.WIDTH_11BIT, ADC.WIDTH_12BIT\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# PWM\n\n# Configurar o pino GPIO onde o PWM será gerado (por exemplo, GPIO15)\npwm_pin = Pin(15)\n\n# Inicializar a saída PWM\npwm = PWM(pwm_pin)\npwm2 = PWM(Pin(2))\n\n# Configurar a frequência do PWM\npwm.freq(1000000)  # 1000 Hz (1 kHz)\npwm2.freq(1000000)  # 1000 Hz (1 kHz)\n\n# Configurar o duty cycle do PWM (0-1023)\npwm.duty(512)  # 50% do duty cycle\npwm2.duty(512)  # 50% do duty cycle\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# Alterar o duty cycle ao longo do tempo e ler o valor do ADC\n\nwhile True:\n    for duty in range(0, 65535, 500):\n        print(duty)\n        pwm.duty_u16(duty)\n        pwm2.duty_u16(duty)\n        \n        valor_adc = adc.read()\n        valor_uv = adc.read_u16()\n        print("Valor ADC:", valor_adc)\n        print("Valor ADC:", valor_uv)\n        \n        time.sleep(0.1)\n\n"""\nO ESP32 possui múltiplos pinos que podem ser usados como entradas ADC (Conversor Analógico-Digital). Existem duas unidades de ADC, ADC1 e ADC2, com um total de 18 canais ADC disponíveis. Aqui estão os pinos que você pode usar para ADC:\n\nADC1 (8 canais)\nGPIO32 (ADC1_CH4)\n\nGPIO33 (ADC1_CH5)\n\nGPIO34 (ADC1_CH6)\n\nGPIO35 (ADC1_CH7)\n\nGPIO36 (ADC1_CH0)\n\nGPIO37 (ADC1_CH1)\n\nGPIO38 (ADC1_CH2)\n\nGPIO39 (ADC1_CH3)\n\nADC2 (10 canais)\nGPIO0 (ADC2_CH1)\n\nGPIO2 (ADC2_CH2)\n\nGPIO4 (ADC2_CH0)\n\nGPIO12 (ADC2_CH5)\n\nGPIO13 (ADC2_CH4)\n\nGPIO14 (ADC2_CH6)\n\nGPIO15 (ADC2_CH3)\n\nGPIO25 (ADC2_CH8)\n\nGPIO26 (ADC2_CH9)\n\nGPIO27 (ADC2_CH7)\n\nNota:\nADC1 vs ADC2:\n\nADC1: Pode ser usado para leituras ADC normalmente, mesmo durante o uso do WiFi.\n\nADC2: Pode ter conflitos quando o WiFi está ativo, pois compartilha recursos de hardware com o WiFi do ESP32.\n"""', name='Run', argv=[], id='cmd_410', local_cwd='C:\\Users\\lucas')
17:50:36.463 [MainThread] INFO    thonny: TIME/MODS 0.943 After Run 
17:57:36.512 [MainThread] INFO    thonny: TIME/MODS 420.050 Before Run 
17:57:36.571 [MainThread] INFO    thonny.running: Prepared clean state for executing ToplevelCommand(args=['-c'], args_str='-c $EDITOR_CONTENT', cmd_line='%Run -c $EDITOR_CONTENT', tty_mode=True, source='from machine import ADC, PWM, Pin\nimport time\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# ADC\n\n# Configurar o pino ao qual o sensor está conectado (por exemplo, GPIO 32)\nadc_pin = Pin(4, mode=Pin.IN)\n\n# Inicializar o ADC\nadc = ADC(adc_pin)\n\n# Configurar a atenuação (opcional, melhora a leitura em diferentes ranges de tensão)\nadc.atten(ADC.ATTN_11DB)  # Opções: ADC.ATTN_0DB, ADC.ATTN_2_5DB, ADC.ATTN_6DB, ADC.ATTN_11DB\n# A atenuação de 11DB é a máxima e permite leituras de 0V a 3,6V\n\n# Configurar a largura do bit (opcional)\nadc.width(ADC.WIDTH_12BIT)  # Opções: ADC.WIDTH_9BIT, ADC.WIDTH_10BIT, ADC.WIDTH_11BIT, ADC.WIDTH_12BIT\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# PWM\n\n# Configurar o pino GPIO onde o PWM será gerado (por exemplo, GPIO15)\npwm_pin = Pin(15)\n\n# Inicializar a saída PWM\npwm = PWM(pwm_pin)\npwm2 = PWM(Pin(2))\n\n# Configurar a frequência do PWM\npwm.freq(1000000)  # 1000 Hz (1 kHz)\npwm2.freq(1000000)  # 1000 Hz (1 kHz)\n\n# Configurar o duty cycle do PWM (0-1023)\npwm.duty(512)  # 50% do duty cycle\npwm2.duty(512)  # 50% do duty cycle\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# Alterar o duty cycle ao longo do tempo e ler o valor do ADC\n\nwhile True:\n    for duty in range(0, 65535, 500):\n        print(duty)\n        pwm.duty_u16(duty)\n        pwm2.duty_u16(duty)\n        \n        valor_adc = adc.read()\n        valor_uv = adc.read_u16()\n        print("Valor ADC:", valor_adc)\n        print("Valor ADC:", valor_uv)\n        \n        time.sleep(0.5)\n\n"""\nO ESP32 possui múltiplos pinos que podem ser usados como entradas ADC (Conversor Analógico-Digital). Existem duas unidades de ADC, ADC1 e ADC2, com um total de 18 canais ADC disponíveis. Aqui estão os pinos que você pode usar para ADC:\n\nADC1 (8 canais)\nGPIO32 (ADC1_CH4)\n\nGPIO33 (ADC1_CH5)\n\nGPIO34 (ADC1_CH6)\n\nGPIO35 (ADC1_CH7)\n\nGPIO36 (ADC1_CH0)\n\nGPIO37 (ADC1_CH1)\n\nGPIO38 (ADC1_CH2)\n\nGPIO39 (ADC1_CH3)\n\nADC2 (10 canais)\nGPIO0 (ADC2_CH1)\n\nGPIO2 (ADC2_CH2)\n\nGPIO4 (ADC2_CH0)\n\nGPIO12 (ADC2_CH5)\n\nGPIO13 (ADC2_CH4)\n\nGPIO14 (ADC2_CH6)\n\nGPIO15 (ADC2_CH3)\n\nGPIO25 (ADC2_CH8)\n\nGPIO26 (ADC2_CH9)\n\nGPIO27 (ADC2_CH7)\n\nNota:\nADC1 vs ADC2:\n\nADC1: Pode ser usado para leituras ADC normalmente, mesmo durante o uso do WiFi.\n\nADC2: Pode ter conflitos quando o WiFi está ativo, pois compartilha recursos de hardware com o WiFi do ESP32.\n"""', name='Run', argv=[], id='cmd_415', local_cwd='C:\\Users\\lucas')
17:57:36.572 [MainThread] INFO    thonny.plugins.micropython.mp_front: Listing serial ports
17:57:36.578 [MainThread] INFO    thonny: TIME/MODS 0.065 After Run 
17:59:02.067 [MainThread] INFO    thonny: TIME/MODS 85.489 Before Run 
17:59:02.067 [MainThread] INFO    thonny.running: Trying to execute current but runner is 'running'
17:59:04.100 [MainThread] INFO    thonny.running: Prepared clean state for executing ToplevelCommand(args=['-c'], args_str='-c $EDITOR_CONTENT', cmd_line='%Run -c $EDITOR_CONTENT', tty_mode=True, source='from machine import ADC, PWM, Pin\nimport time\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# ADC\n\n# Configurar o pino ao qual o sensor está conectado (por exemplo, GPIO 32)\nadc_pin = Pin(4, mode=Pin.IN)\n\n# Inicializar o ADC\nadc = ADC(adc_pin)\n\n# Configurar a atenuação (opcional, melhora a leitura em diferentes ranges de tensão)\nadc.atten(ADC.ATTN_11DB)  # Opções: ADC.ATTN_0DB, ADC.ATTN_2_5DB, ADC.ATTN_6DB, ADC.ATTN_11DB\n# A atenuação de 11DB é a máxima e permite leituras de 0V a 3,6V\n\n# Configurar a largura do bit (opcional)\nadc.width(ADC.WIDTH_12BIT)  # Opções: ADC.WIDTH_9BIT, ADC.WIDTH_10BIT, ADC.WIDTH_11BIT, ADC.WIDTH_12BIT\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# PWM\n\n# Configurar o pino GPIO onde o PWM será gerado (por exemplo, GPIO15)\npwm_pin = Pin(15)\n\n# Inicializar a saída PWM\npwm = PWM(pwm_pin)\npwm2 = PWM(Pin(2))\n\n# Configurar a frequência do PWM\npwm.freq(1000)  # 1000 Hz (1 kHz)\npwm2.freq(1000)  # 1000 Hz (1 kHz)\n\n# Configurar o duty cycle do PWM (0-1023)\npwm.duty(512)  # 50% do duty cycle\npwm2.duty(512)  # 50% do duty cycle\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# Alterar o duty cycle ao longo do tempo e ler o valor do ADC\n\nwhile True:\n    for duty in range(0, 65535, 500):\n        print(duty)\n        pwm.duty_u16(duty)\n        pwm2.duty_u16(duty)\n        \n        valor_adc = adc.read()\n        valor_uv = adc.read_u16()\n        print("Valor ADC:", valor_adc)\n        print("Valor ADC:", valor_uv)\n        \n        time.sleep(0.5)\n\n"""\nO ESP32 possui múltiplos pinos que podem ser usados como entradas ADC (Conversor Analógico-Digital). Existem duas unidades de ADC, ADC1 e ADC2, com um total de 18 canais ADC disponíveis. Aqui estão os pinos que você pode usar para ADC:\n\nADC1 (8 canais)\nGPIO32 (ADC1_CH4)\n\nGPIO33 (ADC1_CH5)\n\nGPIO34 (ADC1_CH6)\n\nGPIO35 (ADC1_CH7)\n\nGPIO36 (ADC1_CH0)\n\nGPIO37 (ADC1_CH1)\n\nGPIO38 (ADC1_CH2)\n\nGPIO39 (ADC1_CH3)\n\nADC2 (10 canais)\nGPIO0 (ADC2_CH1)\n\nGPIO2 (ADC2_CH2)\n\nGPIO4 (ADC2_CH0)\n\nGPIO12 (ADC2_CH5)\n\nGPIO13 (ADC2_CH4)\n\nGPIO14 (ADC2_CH6)\n\nGPIO15 (ADC2_CH3)\n\nGPIO25 (ADC2_CH8)\n\nGPIO26 (ADC2_CH9)\n\nGPIO27 (ADC2_CH7)\n\nNota:\nADC1 vs ADC2:\n\nADC1: Pode ser usado para leituras ADC normalmente, mesmo durante o uso do WiFi.\n\nADC2: Pode ter conflitos quando o WiFi está ativo, pois compartilha recursos de hardware com o WiFi do ESP32.\n"""', name='Run', argv=[], id='cmd_417', local_cwd='C:\\Users\\lucas')
17:59:04.100 [MainThread] INFO    thonny.plugins.micropython.mp_front: Listing serial ports
17:59:04.105 [MainThread] INFO    thonny: TIME/MODS 2.038 After Run 
17:59:21.394 [MainThread] INFO    thonny: TIME/MODS 17.289 Before Run 
17:59:21.395 [MainThread] INFO    thonny.running: Trying to execute current but runner is 'running'
17:59:21.775 [MainThread] INFO    thonny.running: Prepared clean state for executing ToplevelCommand(args=['-c'], args_str='-c $EDITOR_CONTENT', cmd_line='%Run -c $EDITOR_CONTENT', tty_mode=True, source='from machine import ADC, PWM, Pin\nimport time\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# ADC\n\n# Configurar o pino ao qual o sensor está conectado (por exemplo, GPIO 32)\nadc_pin = Pin(4, mode=Pin.IN)\n\n# Inicializar o ADC\nadc = ADC(adc_pin)\n\n# Configurar a atenuação (opcional, melhora a leitura em diferentes ranges de tensão)\nadc.atten(ADC.ATTN_11DB)  # Opções: ADC.ATTN_0DB, ADC.ATTN_2_5DB, ADC.ATTN_6DB, ADC.ATTN_11DB\n# A atenuação de 11DB é a máxima e permite leituras de 0V a 3,6V\n\n# Configurar a largura do bit (opcional)\nadc.width(ADC.WIDTH_12BIT)  # Opções: ADC.WIDTH_9BIT, ADC.WIDTH_10BIT, ADC.WIDTH_11BIT, ADC.WIDTH_12BIT\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# PWM\n\n# Configurar o pino GPIO onde o PWM será gerado (por exemplo, GPIO15)\npwm_pin = Pin(15)\n\n# Inicializar a saída PWM\npwm = PWM(pwm_pin)\npwm2 = PWM(Pin(2))\n\n# Configurar a frequência do PWM\npwm.freq(1000)  # 1000 Hz (1 kHz)\npwm2.freq(1000)  # 1000 Hz (1 kHz)\n\n# Configurar o duty cycle do PWM (0-1023)\n# pwm.duty(512)  # 50% do duty cycle\n# pwm2.duty(512)  # 50% do duty cycle\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# Alterar o duty cycle ao longo do tempo e ler o valor do ADC\n\nwhile True:\n    for duty in range(0, 65535, 500):\n        print(duty)\n        pwm.duty_u16(duty)\n        pwm2.duty_u16(duty)\n        \n        valor_adc = adc.read()\n        valor_uv = adc.read_u16()\n        print("Valor ADC:", valor_adc)\n        print("Valor ADC:", valor_uv)\n        \n        time.sleep(0.5)\n\n"""\nO ESP32 possui múltiplos pinos que podem ser usados como entradas ADC (Conversor Analógico-Digital). Existem duas unidades de ADC, ADC1 e ADC2, com um total de 18 canais ADC disponíveis. Aqui estão os pinos que você pode usar para ADC:\n\nADC1 (8 canais)\nGPIO32 (ADC1_CH4)\n\nGPIO33 (ADC1_CH5)\n\nGPIO34 (ADC1_CH6)\n\nGPIO35 (ADC1_CH7)\n\nGPIO36 (ADC1_CH0)\n\nGPIO37 (ADC1_CH1)\n\nGPIO38 (ADC1_CH2)\n\nGPIO39 (ADC1_CH3)\n\nADC2 (10 canais)\nGPIO0 (ADC2_CH1)\n\nGPIO2 (ADC2_CH2)\n\nGPIO4 (ADC2_CH0)\n\nGPIO12 (ADC2_CH5)\n\nGPIO13 (ADC2_CH4)\n\nGPIO14 (ADC2_CH6)\n\nGPIO15 (ADC2_CH3)\n\nGPIO25 (ADC2_CH8)\n\nGPIO26 (ADC2_CH9)\n\nGPIO27 (ADC2_CH7)\n\nNota:\nADC1 vs ADC2:\n\nADC1: Pode ser usado para leituras ADC normalmente, mesmo durante o uso do WiFi.\n\nADC2: Pode ter conflitos quando o WiFi está ativo, pois compartilha recursos de hardware com o WiFi do ESP32.\n"""', name='Run', argv=[], id='cmd_419', local_cwd='C:\\Users\\lucas')
17:59:21.776 [MainThread] INFO    thonny.plugins.micropython.mp_front: Listing serial ports
17:59:21.780 [MainThread] INFO    thonny: TIME/MODS 0.386 After Run 
17:59:58.597 [MainThread] INFO    thonny: TIME/MODS 36.817 Before Run 
17:59:58.597 [MainThread] INFO    thonny.running: Trying to execute current but runner is 'running'
17:59:58.955 [MainThread] INFO    thonny.running: Prepared clean state for executing ToplevelCommand(args=['-c'], args_str='-c $EDITOR_CONTENT', cmd_line='%Run -c $EDITOR_CONTENT', tty_mode=True, source='from machine import ADC, PWM, Pin\nimport time\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# ADC\n\n# Configurar o pino ao qual o sensor está conectado (por exemplo, GPIO 32)\nadc_pin = Pin(4, mode=Pin.IN)\n\n# Inicializar o ADC\nadc = ADC(adc_pin)\n\n# Configurar a atenuação (opcional, melhora a leitura em diferentes ranges de tensão)\nadc.atten(ADC.ATTN_11DB)  # Opções: ADC.ATTN_0DB, ADC.ATTN_2_5DB, ADC.ATTN_6DB, ADC.ATTN_11DB\n# A atenuação de 11DB é a máxima e permite leituras de 0V a 3,6V\n\n# Configurar a largura do bit (opcional)\nadc.width(ADC.WIDTH_12BIT)  # Opções: ADC.WIDTH_9BIT, ADC.WIDTH_10BIT, ADC.WIDTH_11BIT, ADC.WIDTH_12BIT\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# PWM\n\n# Configurar o pino GPIO onde o PWM será gerado (por exemplo, GPIO15)\npwm_pin = Pin(15)\n\n# Inicializar a saída PWM\npwm = PWM(pwm_pin)\npwm2 = PWM(Pin(2))\n\n# Configurar a frequência do PWM\npwm.freq(1000)  # 1000 Hz (1 kHz)\npwm2.freq(1000)  # 1000 Hz (1 kHz)\n\n# Configurar o duty cycle do PWM (0-1023)\n# pwm.duty(512)  # 50% do duty cycle\n# pwm2.duty(512)  # 50% do duty cycle\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# Alterar o duty cycle ao longo do tempo e ler o valor do ADC\n\nwhile True:\n    for duty in range(0, 1024):\n        print(duty)\n        pwm.duty(duty)\n        pwm2.duty(duty)\n        \n        valor_adc = adc.read()\n        valor_uv = adc.read_u16()\n        print("Valor ADC:", valor_adc)\n        print("Valor ADC:", valor_uv)\n        \n        time.sleep(0.5)\n\n"""\nO ESP32 possui múltiplos pinos que podem ser usados como entradas ADC (Conversor Analógico-Digital). Existem duas unidades de ADC, ADC1 e ADC2, com um total de 18 canais ADC disponíveis. Aqui estão os pinos que você pode usar para ADC:\n\nADC1 (8 canais)\nGPIO32 (ADC1_CH4)\n\nGPIO33 (ADC1_CH5)\n\nGPIO34 (ADC1_CH6)\n\nGPIO35 (ADC1_CH7)\n\nGPIO36 (ADC1_CH0)\n\nGPIO37 (ADC1_CH1)\n\nGPIO38 (ADC1_CH2)\n\nGPIO39 (ADC1_CH3)\n\nADC2 (10 canais)\nGPIO0 (ADC2_CH1)\n\nGPIO2 (ADC2_CH2)\n\nGPIO4 (ADC2_CH0)\n\nGPIO12 (ADC2_CH5)\n\nGPIO13 (ADC2_CH4)\n\nGPIO14 (ADC2_CH6)\n\nGPIO15 (ADC2_CH3)\n\nGPIO25 (ADC2_CH8)\n\nGPIO26 (ADC2_CH9)\n\nGPIO27 (ADC2_CH7)\n\nNota:\nADC1 vs ADC2:\n\nADC1: Pode ser usado para leituras ADC normalmente, mesmo durante o uso do WiFi.\n\nADC2: Pode ter conflitos quando o WiFi está ativo, pois compartilha recursos de hardware com o WiFi do ESP32.\n"""', name='Run', argv=[], id='cmd_421', local_cwd='C:\\Users\\lucas')
17:59:58.955 [MainThread] INFO    thonny.plugins.micropython.mp_front: Listing serial ports
17:59:58.960 [MainThread] INFO    thonny: TIME/MODS 0.363 After Run 
18:00:40.092 [MainThread] INFO    thonny: TIME/MODS 41.131 Before Run 
18:00:40.092 [MainThread] INFO    thonny.running: Trying to execute current but runner is 'running'
18:00:40.491 [MainThread] INFO    thonny.running: Prepared clean state for executing ToplevelCommand(args=['-c'], args_str='-c $EDITOR_CONTENT', cmd_line='%Run -c $EDITOR_CONTENT', tty_mode=True, source='from machine import ADC, PWM, Pin\nimport time\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# ADC\n\n# Configurar o pino ao qual o sensor está conectado (por exemplo, GPIO 32)\nadc_pin = Pin(4, mode=Pin.IN)\n\n# Inicializar o ADC\nadc = ADC(adc_pin)\n\n# Configurar a atenuação (opcional, melhora a leitura em diferentes ranges de tensão)\nadc.atten(ADC.ATTN_11DB)  # Opções: ADC.ATTN_0DB, ADC.ATTN_2_5DB, ADC.ATTN_6DB, ADC.ATTN_11DB\n# A atenuação de 11DB é a máxima e permite leituras de 0V a 3,6V\n\n# Configurar a largura do bit (opcional)\nadc.width(ADC.WIDTH_12BIT)  # Opções: ADC.WIDTH_9BIT, ADC.WIDTH_10BIT, ADC.WIDTH_11BIT, ADC.WIDTH_12BIT\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# PWM\n\n# Configurar o pino GPIO onde o PWM será gerado (por exemplo, GPIO15)\npwm_pin = Pin(15)\n\n# Inicializar a saída PWM\npwm = PWM(pwm_pin)\npwm2 = PWM(Pin(2))\n\n# Configurar a frequência do PWM\npwm.freq(1000)  # 1000 Hz (1 kHz)\npwm2.freq(1000)  # 1000 Hz (1 kHz)\n\n# Configurar o duty cycle do PWM (0-1023)\n# pwm.duty(512)  # 50% do duty cycle\n# pwm2.duty(512)  # 50% do duty cycle\n\n# ---------------------------------------------------------------------------------------------------------------------\n\n# Alterar o duty cycle ao longo do tempo e ler o valor do ADC\n\nwhile True:\n    for duty in range(0, 1024):\n        print(duty)\n        pwm.duty(duty)\n        pwm2.duty(duty)\n        \n        valor_adc = adc.read()\n        valor_uv = adc.read_u16()\n        print("Valor ADC:", valor_adc)\n        print("Valor ADC:", valor_uv)\n        \n        time.sleep(0.1)\n\n"""\nO ESP32 possui múltiplos pinos que podem ser usados como entradas ADC (Conversor Analógico-Digital). Existem duas unidades de ADC, ADC1 e ADC2, com um total de 18 canais ADC disponíveis. Aqui estão os pinos que você pode usar para ADC:\n\nADC1 (8 canais)\nGPIO32 (ADC1_CH4)\n\nGPIO33 (ADC1_CH5)\n\nGPIO34 (ADC1_CH6)\n\nGPIO35 (ADC1_CH7)\n\nGPIO36 (ADC1_CH0)\n\nGPIO37 (ADC1_CH1)\n\nGPIO38 (ADC1_CH2)\n\nGPIO39 (ADC1_CH3)\n\nADC2 (10 canais)\nGPIO0 (ADC2_CH1)\n\nGPIO2 (ADC2_CH2)\n\nGPIO4 (ADC2_CH0)\n\nGPIO12 (ADC2_CH5)\n\nGPIO13 (ADC2_CH4)\n\nGPIO14 (ADC2_CH6)\n\nGPIO15 (ADC2_CH3)\n\nGPIO25 (ADC2_CH8)\n\nGPIO26 (ADC2_CH9)\n\nGPIO27 (ADC2_CH7)\n\nNota:\nADC1 vs ADC2:\n\nADC1: Pode ser usado para leituras ADC normalmente, mesmo durante o uso do WiFi.\n\nADC2: Pode ter conflitos quando o WiFi está ativo, pois compartilha recursos de hardware com o WiFi do ESP32.\n"""', name='Run', argv=[], id='cmd_423', local_cwd='C:\\Users\\lucas')
18:00:40.491 [MainThread] INFO    thonny.plugins.micropython.mp_front: Listing serial ports
18:00:40.496 [MainThread] INFO    thonny: TIME/MODS 0.404 After Run 
18:01:52.189 [Thread-18 (_listen_stdout)] INFO    thonny.running: Reader got EOF
18:01:52.310 [MainThread] INFO    thonny.shell: BaseShellText._on_backend_terminated
